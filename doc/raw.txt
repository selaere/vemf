:title: About
if you are reading this, you are reading the vemf documentation. the vemf documentation has information about all of the different characters, verbs, nouns and adverbs that vemf has.
this documentation can be enjoyed in a ||"raw" text format@https://github.com/selaere/vemf/blob/main/doc/raw.txt|| or in a ||nice html webpage format@https://selaere.github.io/vemf/doc/docs.html||. the raw format is converted to html with ||a vemf script@https://github.com/selaere/vemf/blob/main/doc/gen.vemf||.
but not only does this documentation have text. in fact i am bad at explaining stuff, so there are way more examples than text. here's one!
> "hello world i am a vemf test"\"aeiou" ≡ "hll wrld  m  vmf tst"
the vemf documentation is not only a documentation, it doubles as a test suite! when the tests are run, the expressions to both sides of the ` ≡ ` are evaluated, and checked for equality. if you see an example like this:
> 1+1 ≡ 2
you know it will work in the latest vemf version!
the main way to play around with vemf is the interactive repl.
>     1+1
> 2
>     __*3
> 6
the indented lines are input, and the result is unindented and ||formatted@#Format|| automatically. the default formatting is not always what you want though:
>     "hello world i am a vemf test"\"aeiou"
> (104 108 108 32 119 114 108 100 32 32 109 32 32 118 109 102 32 116 115 116)
in the repl, you can format it into a string by using `)4 ` (see ||Format||)
>     )4 "hello world i am a vemf test"\"aeiou"
> "hll wrld  m  vmf tst"
if you evaluate something like "tangent of pi radians", thanks to floating-point shenanigans, you can get small inaccuracies:
>     πâ
> -0.00000000000000012246467991473532
when testing those we use ` ± ` ||Approximate Equal||, and if a test passes, the results are within about 10 significant figures.
> πâ ± 0
not everything can be automatically tested. functions that rely on the random number generator, like `áàå`, won't give the same results everytime, so tests with `?≡` are ignored.
> 5á ?≡ 3
---
:title: Basics
here's a vemf expression!
> 1+2 ≡ 3
surprising! vemf can do maths. there are more operations, of course,
> 3*2 ≡ 6
> 8/4 ≡ 2
> 2*3+1 ≡ 7
characters like `+ - * /` are functions. here they take two arguments at each side: `α+β`.
evaluation of functions is strictly left to right:
> 1+2*3 ≡ 9
functions may also be called with one argument (monadic) instead of two (dyadic), by only giving the left argument `α+`. here you can see `-` being called as `α-` ||Negate|| and `α-β` ||Subtract||:
> 3-1 ≡ 2
> 4+2- ≡ _6
> 4+2-- ≡ 6
> 5- ≡ _5
> 5--3 ≡ _8
, where `_5`, `_6`, `_8` are constants meaning −5, −6, −8 respectively.
almost every function has two different variants that do different things. even `+`! monadic `α+` ||Sum|| adds all the items in a list:
> 123+ ≡ 6
uh, hm. yes. this is not the number one hundred and twenty-three. consecutive values form a list, and `1`, `2`, `3` are values. the sum of all of those is 6.
if you do want the number 123, you can use ||Numeric Literal||s by prepending a `:` colon:
> :123+1 ≡ :124
> :12:33:-4+ ≡ :41
or even shorter (and more obscure), we can use a ||Character Literal|| with a backtick. `z` is the 123rd character in ||the codepage@#The Codepage||, so:
> `z+1 ≡ :123
note that whitespace matters when using numeric literals:
> :12 34+ ≡ :19
> :123 4+ ≡ :127
you may use parentheses to group expressions:
> 1+(2*3) ≡ 7
here, `2*3` is another expression that is executed before the outer one, and `(2*3)` is a single value.
the mathematical operations you are familiar with are here. arithmetic `+-*/`, `^` ||Exponent||, `∟` ||Logarithm||, and a bunch more.
---
:title: Lists
a list is a finite ordered collection of values. lists can be created with stranding syntax, which just means putting values next to each other:
>     123
> (1 2 3)
>     :16:25:36:49:64
> (16 25 36 49 64)
lists may be nested arbitrarily deep. this is a list composed of 3 lists, each with 3 items (or, if you prefer, a 3 by 3 matrix).
>     (123)(456)(789)
> ((1 2 3) (4 5 6) (7 8 9))
the arguments of a list dont have to have the same length or the same type:
>     (036)9 
> ((0 3 6) 9)
>     (98)(123)(4567)
> ((9 8) (1 2 3) (4 5 6 7))
we can get a list's length with `α~`:
> 123~ ≡ 3
in vemf, strings are lists of characters (rather, Unicode codepoints). a string literal makes a list with all the characters inside the ||Quotes||, in vemf's codepage:
> "abc" ≡ :97:98:99
> "♥♦♣♠" ≡ 3456
> "Hello, World!"~ ≡ :13
strings can be stranded as well:
>     "earth""fire""air""water"
> ((101 97 114 116 104) (102 105 114 101) (97 105 114) (119 97 116 101 114))
>     )4 "earth""fire""air""water"
> ("earth" "fire" "air" "water")
functions that work with numbers are scalar functions: they automatically distribute to every number in a list. for two lists, this pairs up the elements and operates on them:
> 012*345 ≡ 0 4 :10
if one argument is a list and another is a scalar, the scalar is 'distributed' to all the items in the array:
> 63102+2 ≡ 85324
> 1/234 ≡ (1/2)(1/3)(1/4)
these rules are applied recursively:
> (123)(456)(789)+01(323) ≡ (123)(567)(:10:10:12)
see also: ||Each||, ||Conform||
comparison functions, like `< = > ≤ ~ ≥` (`α~β` is ||Not Equals||), are scalar as well, and they return a 1 if true, otherwise 0:
> "cat"="cow" ≡ 100
> "cat"="cat" ≡ 111
> (0123)(456)(78)9>5 ≡ (0000)(001)(11)1
> "pickled peppers"~`p ≡ 011111110100111
though it's useful to compare if two lists are equal, so there is also `≡` ||Matches|| and `≈` ||Not Matches||
> "cat"≡"cow" ≡ 0
> "cat"≡"cat" ≡ 1
we've seen that characters are not a separate type, and they are just their codepoints. subtracting an ascii lowercase letter by 32 makes it uppercase, so we can make a word uppercase by:
> "screaming"-:32 ≡ "SCREAMING"
though there's also another function for this, `Ç` ||Uppercase||, and it leaves punctuation unchanged:
> "words words"Ç ≡ "WORDS WORDS"
an element in a list can be indexed with `α@β` ||Index||, where indices start with 0:
> 2468@2 ≡ 6
> 2468@0 ≡ 2
> 2468@ ≡ 2 ' monadic @ is First
> (123)(456)(789)@2 ≡ 789
> (123)(456)(789)@21 ≡ 8
`α,β` ||Concatenate||s lists:
> 123,456 ≡ 123456
> 1,234 ≡ 1234
> (12)(34),56 ≡ (12)(34)56
and `α♫β` creates a ||Pair||:
> 123♫456 ≡ (123)(456)
`α↕` ||Iota|| returns all the integers from 0 up to α:
> 5↕ ≡ 01234
if you want something more familiar, try `α↨` ||Inclusive Iota||:
> 5↨ ≡ 12345
all lists have a fill, usually `■` ||None||. you can think of the fill as a dummy element for the elements outside of its domain. when you index out of range, you will get the fill:
> 123@3 ≡ ■
the default fill is ||None||. you can specify the fill of a list `α▐β` ||Set Fill||, and query it with `α▐` ||Get Fill||.
> 123▐0@3 ≡ 0
> 123▐ ≡ ■
> 123▐0▐ ≡ 0
`α↑β` ||Take|| takes the first β items, and `α♂β` ||Drop|| returns everything but the first β items:
> "javascript"↑4 ≡ "java"
> "javascript"♂4 ≡ "script"
`↓` ||Take Right|| and `♀` ||Drop Right|| use the last items instead:
> "file.txt"↓4 ≡ ".txt"
> "file.txt"♀4 ≡ "file"
these use the fill when the list runs out:
> "js"▐` ↑5 ≡ "js   "
> "js"▐` ↓5 ≡ "   js"
but `α¶β` ||Reshape|| starts taking from the start when it runs out of items:
> 123¶9 ≡ 123123123
> "sal"¶5 ≡ "salsa"
`↑`, `↓` and `¶` with a list as a right argument can reshape, or create a nested list with those dimensions:
> 0123456789↑33 ≡ (012)(345)(678)
> 0123456789↓33 ≡ (123)(456)(789)
> 1234¶43 ≡ (123)(412)(341)(234)
---
:title: Adverbs
adverbs are a syntax for functions that take other functions. take one of the most basic: ||Selfie|| `┴G` takes a function `G` and returns a function that applies `G` with the same argument used twice:
> 123┴+ ≡ 246
> 123┴* ≡ 149
> "bee"┴, ≡ "beebee"
> "bee"┴♫ ≡ "bee""bee"
and if ||Swap|| `┴G` is called with two arguments, it returns a functions that applies `G` with its arguments flipped:
> 6┴-2 ≡ _4
> 4┴/1 ≡ 1/4  ' reciprocal
there are two types of adverbs. 1-adverbs, like `┴G` ||Selfie||/||Swap||, take one operand after them, and the whole acts as a verb. 2-adverbs, like `F║G` ||Over||, take two operands at both sides. Over applies `G` to each argument, and then `F`:
> 4²║+5 ≡ 4²+(5²)
> 4²║▲ ≡ 4²▲
adverb precedence is right-to-left.
> 4┴²║-5 ≡ 5²-(4²)
additionally, 1-adverbs can be used before 2-adverbs, and this applies them to the left operand:
> 4*┴║-5 ≡ 4(┴*)║-5
> 4*┴║-5 ≡ 4*4-(5*5)
the built-in adverbs are all box-drawing symbols (though not all box-drawing symbols are adverbs). 1-adverbs have a single vertical line and 2-adverbs have a double vertical lines:
> 1-adverbs: ╪┼┴┬╧╤╕╒╛╘┐┌
> 2-adverbs: ╬╫╨╥╩╦╖╓╜╙╗╔║
these adverbs have a variety of uses. some of them are ||Combinators||, like the ones that we've just seen, and they apply the operands in various ways. some are more interesting, though.
# Iteration
vemf automatically vectorizes, so often explicit loops are usually not necessary. however, some adverbs can be used to explicitly iterate in a certain way
`α╕G` ||Each|| applies G to every item in α:
> (123)(45)(6789)"aaaaaa"╕~ ≡ 3246
`α╕Gβ` ||Each|| (dyadic) pairs the items up and applies G to each pair:
> 123╕,456 ≡ (14)(25)(36)
`α╛Gβ` ||Each Left|| and `α╘Gβ` ||Each Right|| iterate through one argument, while passing the other argument:
> 123╛,456 ≡ (1456)(2456)(3456)
> 123╘,456 ≡ (1234)(1235)(1236)
using both Each Left and Each Right we get something similar to APL's outer product, or a cartesian product:
> 123╘╛,456 ≡ ((14)(24)(34))((15)(25)(35))((16)(26)(36))
> 123╛╘,456 ≡ ((14)(15)(16))((24)(25)(26))((34)(35)(36))
`α╧G` ||Reduce|| is like applying G between every element in α, progressively building up a value: 
> 2345╧+ ≡ 2+3+4+5
this is similar to the monadic use of addition, `α+` ||Sum||. in fact, `*` `,` `&` `&#x7c;` `ñ` `Ñ` all act the same way: the monad is the reduction of the dyad.
`α╤G` ||Scan|| gives the intermediate results of the reduction:
> 2345╤+ ≡ (2)(2+3)(2+3+4)(2+3+4+5)
> 00100010011020╤+ ≡ 00111122234466
`αF╨G` ||Power|| calls G, `αF` times
> 14╨┴♫ ≡ ( ((11)(11)) ((11)(11)) )( ((11)(11)) ((11)(11)) )
(note that `14` is not a strand, `4` is an operand of the 2-adverb, and `1` is an argument)
`αF╩G` ||Until|| calls G until `αF` returns not 0.
# Combinators
combinators call their operands in different ways. they are one of the main ways functions are defined; combinators are the "glue" that joins different functions.
vemf has a lot of different combinators! here's a summary, using `+` `/` `*` as examples:
> NAME         : MONADIC, DYADIC
> atop      +/ : α+/    , α+β/
> swap      ┴/ : α/α    , β/α
> atleft   +╜/ : α+/    , α+/β
> atright  +╙/ : α/     , α/(β+)
> over     +║/ : α+/    , α+/(β+)
> onleft   +╖/ : α+/α   , α+β/β
> onright  +╓/ : α/(α+) , α/(α+β)
> fork    └+/* : α+/(α*), α+β/(α*β)
there is also a ""3-adverb"" of sorts, the `└FGH` ||Fork||. it works a little differently, it is a prefix rather than an infix, and is ocassionally useful. for instance, the average (mean) of a list is the sum divided by the length:
> 12345└+/~ ≡ 3
the formula for triangular numbers is n(n+1)/2. we can do the first part as a fork:
> 6└◄*▲ ≡ :42
this is the same as
> 6◄*(6▲) ≡ :42
here, `◄` is the identity function or ||Left||, that always returns the left argument. there is also a `►` ||Right||, that returns the right argument.
> 6◄3 ≡ 6
> 6►3 ≡ 3
> 6*(6▲) ≡ :42
and then we can do the halving with `½` ||Half||:
> 6└◄*▲½ ≡ :21
as a general rule of thumb, when there is a `◄` or `►` in a fork, it can be represented with one of the other combinators. here we can use `αF╓G` ||On Right||, which evaluates to `αG(αF)`
> 6▲╓*½ ≡ :21
here is another way of representing all the combinators that i can test automatically
> ♫,;`(,`)→F ♫,;`[,`]→G ♫,;`{,`}→H ≡ ■
> (`a┴G)   (`a┴G`b)    ≡ "[aa]"    "[ba]"
> (`aF╜G)  (`aF╜G`b)   ≡ "[(a)]"   "[(a)b]"
> (`aF╙G)  (`aF╙G`b)   ≡ "[a]"     "[a(b)]"
> (`aF╖G)  (`aF╖G`b)   ≡ "[(a)a]"  "[(ab)b]"
> (`aF╓G)  (`aF╓G`b)   ≡ "[a(a)]"  "[a(ab)]"
> (`aF║G)  (`aF║G`b)   ≡ "[(a)]"   "[(a)(b)]"
> (`a└FGH) (`a└FGH`b)  ≡ "[(a){a}]""[(ab){ab}]"
> (`aF╜H╙G)(`aF╜H╙G`b) ≡ "[(a)]"   "[(a){b}]"
---
:title: Variables
i will now introduce some terminology. functions, lists and numbers are types of values. in a program, these types can all be used as either nouns or verbs (what we've been calling "values" and "functions" up to now). a function may be used as a noun, and a verb may be used as a function.
a noun can become a verb if you enclose it in parentheses. this way, you can pass functions to other functions. `α$β` ||Call||s α with the pair of arguments β:
> (*)$35 ≡ :15
with built-in functions, you can also use a dot `.` before the name:
> .*$35 ≡ :15
you can also have functions in lists:
> .+.-.*./@3$62 ≡ 3
indexing a function calls it monadically with the index,
> .-@3 ≡ _3
and some list functions, like ||Take||, use this to treat functions as infinite lists:
> .◄↑4 ≡ 0123
> .-↑33 ≡ (0_1_2)(_3_4_5)(_6_7_8)
> .+~ ≡ ∞
characters from `a` to `z` are variables, which are given somewhat-convenient default values.
> abcdefghij ≡ :12:20:99:100:999:1000:10000:100000:1000000:10000000
> klmnopqrst ≡ :15:16:31:32:63:64:127:128:255:256
> uvwxyz     ≡ :512:1024:32768:65536:16777216:2147483648
> f+n ≡ :1032
variables can be set with `→name` and retrieved as a noun with `.name`. the dot is not necessary for variables `a` to `z`.
> :35/7→f 1/f ≡ :0.2
> :35/7→five 1/.five ≡ :0.2
built-in verbs are also variables, and that's why you can get them with a dot. `.` is the noun variable prefix, and `:` is the verb variable prefix:
> 4:*3 ≡ :12
that was useless. but this means you can assign functions and use them as verbs!
> *→mult 4:mult3 ≡ :12
> └+/~→avg 234:avg ≡ 3
`A` to `Z` don't need the colon:
> *→M 4M3 ≡ :12
> └+/~→V 234:avg ≡ 3
calling a number or a list as a verb just makes it return itself:
> :35/7→f 4:f ≡ :5
> :35/7→F 4F  ≡ :5
a name, or identifier, can be a sequence of lowercase letters (`mul`, `six`, `things`), an underscore followed by a character (`_ë`, `_1`) or a single character (`+`, `-`). any other name can be used by using quotes: `."Name of variable"`
`x→name` is a statement that sets x to the variable `.name`. statements are not quite like verbs; you will see more about statements in the ||Statements|| section.
there is another kind of assignment: `─name` ||Set Function|| (that is a box drawing character, not a minus sign `-`). it is a verb that sets α to the variable and returns β or, if not given, α. this makes it flexible to define a variable and then use it.
> 4 ─four 1+2+.four ≡ 7  ' β is 1, return 1 after changing the variable
> 4 ─four +1+2      ≡ 7  ' β not given, return .four back
and for golfing purposes, the functions `A`..`Z` are set by default to `─a`..`─z`, so you can set and get variables conveniently.
> 3+1X+x ≡ 8
---
:title: Trains
we saw earlier that you can assign a verb to a variable with `→name`,
> +→add 4:add5 ≡ 9
and you can use a verb as a noun by enclosing it in parentheses (or, in general, having it at the start of an expression)
> (+)$12 ≡ 3
but by having more stuff inside the expression, we can modify the verb in certain ways:
a verb and a noun `Fβ` is called a Bind. it calls F with β as a right argument, ignoring whatever was passed to the right.
> +1→inc 4:inc ≡ 5
> (+1)@5 ≡ 6
> *2→dup 4:dup ≡ 8
> *2→dup 4:dup9 ≡ 8
(note that `inc` and `dup` are equivalent to `α▲` ||Bump Up|| and `α¼` ||Double||)
> +1→inc 4:inc ≡ 5
> *2→dup 4:dup ≡ 8
> *2→dup 4:dup9 ≡ 8
a verb and a verb `FG` is an Atop. it calls F with all arguments, and then calls G atop of that.
> ↨*→fact 6:fact ≡ :720
> ~↕→dom  "text":dom ≡ 0123
> |¬→nor  0:nor1 ≡ 0
(note that `fact`, `dom`, `nor` are equivalent to `α!` ||Factorial|| (for natural α), `α♣` ||Domain|| and `αöβ` ||Nor||)
verb+verb+noun `FGβ` is a mix of the two: it calls F with both arguments, and then calls G atop of that using β as a right argument.
> +/2→avg  4:avg8 ≡ 6
> ²*π→area 3:area ≡ 9*π
(note that `π` is pi, the number)
you can chain these, left-to-right
> +1+2+3→f 5:f ≡ :11
> ~=0→empty φ:empty ≡ 1
we've been setting these trains to variables before using them. it won't work if you try to apply them directly with parentheses:
> 5(+/2)9
is a list with `5`, the function `+/2` (as a noun) and `9`. you can turn a noun into a verb with ||Verbize|| `┘`:
> 5┘(+/2)9 ≡ 7
> 6┘(↨*) ≡ :720
but you never actually need to do this! an inlined train will always be shorter:
> 5+9/2 ≡ 7
> 6↨* ≡ :720
trains are also useful when used with adverbs:
> ' if length is 3, uppercase
> "and""the""small""bee""wanted""to""fly"╕(~=3)╨Ç ≡ "AND""THE""small""BEE""wanted""to""FLY"
we can create a variable from the triangular number function from earlier with a train.
the `½` is applied atop the result of the fork, so as a single function this is an atop:
> 6▲╓*½ ≡ :21
> 6┘(▲╓*½) ≡ :21
note that we need the `┘` for it to be interpreted as a function.
we can set our function to a variable and use it.
> ▲╓*½→triang 6:triang ≡ :21
this way of defining functions, stringing other functions together with combinators— is an important part of vemf. you might hear it being called "tacit programming" or "point-free style". note how we never refer to our arguments by name. we can also define this function explicitly (see ||Statements||):
> {α*(α▲)½}→triang 6:triang ≡ :21
> {α▲*α½}→triang 6:triang ≡ :21  ' multiplication is commutative
but the tacit form is simpler (and shorter, and somewhat faster).
---
:title: Groups
i don't like parentheses. i don't like the fact that occasionally i have to use them to make things work. i don't like that precedence is a thing. but alas, this is not a stack language, and we ocassionally need to group things. but parentheses take up a lot of space, and something as simple as `+2` gains two characters when used with an adverb `(+2)╜/`. 
> 7 (+2)╜/ 3
precedence adjusting is annoying:
> :42→a "I think ",(aª)," is a good number." ≡ "I think 42 is a good number."
nested list literals can also get unwieldy:
> (123)(45)(6789)
the solution is group characters. group characters act like parentheses, but instead of terminating when the closing parenthesis is found, how much will be grouped depends the character you use. here are all the groupers:
> 2 3 4 5 6 7 8 9 10
> │ ├ ╞ ╟ ╠ ┤ ╡ ╢ ╣
their basic function is grouping a number of nouns and verbs (or words) together. the number next to them specifies how many will be grouped. the 2-grouper `│` will group 2 words:
> │01│23│45 ≡ (01)(23)(45)
> │012││345│67 ≡ (01)2((34)5)(67)
> ├123│45╞6789 ≡ (123)(45)(6789)
> :42→a "I think ",│aª," is a good number." ≡ "I think 42 is a good number."
there's a pattern to these: when they're pointing to the right the number of lines going out is the number of words grouped, and the symbols for 7, 8, 9, 10 groupers are flipped 3, 4, 5, 6 groupers.
we said that groupers are alternatives to parentheses. in an expression, there are a few places where it makes sense to stop the expression, or to place a closing parenthesis. for example, for the expression `1+2+3`
> (1)+2+3
> (1+)2+3
> (1+2)+3
> (1+2+)3
> (1+2+3)
are all expressions that make sense. if you represent the places where the parentheses can end with spaces: `1 + 2 + 3`
all that groupers do is pick which space to close with:
> │1+2+3 ≡ (1 +)2 + 3
> ├1+2+3 ≡ (1 + 2)+ 3
> ╞1+2+3 ≡ (1 + 2 +)3
> ╟1+2+3 ≡ (1 + 2 + 3)
groupers won't break into literals, parentheses, other groupers, or any other nested structure. `1+(2/3)-:3.14` is split like `1 + (2/3) - :3.14 ²`:
> │1+(2/3)-:3.14² ≡ (1 +)(2/3) - :3.14 ²
> ├1+(2/3)-:3.14² ≡ (1 + (2/3))- :3.14 ²
> ╞1+(2/3)-:3.14² ≡ (1 + (2/3) -):3.14 ²
> ╟1+(2/3)-:3.14² ≡ (1 + (2/3) - :3.14)²
a grouper can't break after an adverb, as adverbs always need a verb after them:
> │a╒+b ≡ (a╒+)b
> │a╕╕(♣♠)b ≡ (a╕╕(♣♠))b
but it can break before a 2-adverb! this is actually really useful to adjust adverb precedence, as doing `(-╖!)║*` is different to `-╖!║*`
> a -╖!║*b ≡ a - ╖! ║* b
> a│-╖!║*b ≡ a(- ╖!)║* b
groupers also can't break between the operands in a fork:
> φ └+╛+╕+║- ≡ φ └+╛+╕+ ║-
> φ┘└+╛+╕+║- ≡ φ(└+╛+╕+)║-
(`┘` ||Verbize|| is also a 1-grouper. this is occasionally useful)
---
:title: Statements
there is a more explicit way of defining functions, and it looks more like lambda expressions you might be used to from other languages:
> 456{α+/(α~)} ≡ 5
> 345{β^(α♣♠)*α+}:10 ≡ :345
that thing inside braces is the ||function definition@#Define Function||, and it uses special variables like `α` or `β` that are always defined inside dfns. the expression inside the braces will be evaluated and returned.
but there's more that you can do inside functions. dfns are composed of multiple statements, and the result of the last one is returned.
statements are delimited by statement separators like `·` ||Discard|| or `◘` ||Return||. discard statements evaluate a value and discard it; return statements return a value from the function.
> ■{1·2·3◘4·5} ≡ 3
not very interesting. you have already seen one statement separator: `→name` assigns the body of the statement to the variable with that name. you can use this in longer pieces of code, to give names to values.
> 456{α+→avg α~→len .avg/.len} ≡ 5
functions create a lexical scope. this means variables you define inside of a function will not be accessible outside.
these become more useful when used with `x?y` ||Then|| (note that Then is not a function), which executes the following statement `y` if `x` is not 0. you can use these for ternary-operator-like things:
> _5{α>0?α◘α-} ≡ 5
the left side of `?` can take a function, and it will be called with the same arguments as the outer function:
> _5{>0?α◘α-} ≡ 5
you can also use statements in ||Blocks||, that work like functions that are immediately evaluated. this can be useful for conditions:
> [1+1=2?"good"◘"bad"] ≡ "good"
or for doing multiple things if a condition holds. blocks don't create their own scope, so:
> 6{α→a 4→b a>b?[a-b→a 0→b]· ab} ≡ 20
---
:title: Programs
# The Codepage
here is the vemf codepage. if you are reading in a browser, you might be seeing this at the left of your screen.
>    | 0123456789abcdef0123456789abcdef
> ---+-----------------++++++++++++++++
> x0 | ¤☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼¶§▬↨↑↓←→∟↔▲▼
> x2 |  !"#$%&'()*+,-./0123456789:;<=>?
> x4 | @ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_
> x6 | `abcdefghijklmnopqrstuvwxyz{|}~⌂
> x8 | ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒ
> xA | áíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐
> xC | └┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀
> xE | αβΓπΣσμτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°¨·√ⁿ²■⎕
this is based on the ||CP-437@https://en.wikipedia.org/wiki/Code_page_437|| codepage. this is the codepage used in the very first IBM PCs! note that
- `◙ 0A` doubles as a ||Line Break||, it is whitespace
- `  20` is a space
- `¨ F9` represents `¨ U+00A8 DIAERESIS`, while CP-437 uses a small middle dot. it is encoded in Unicode as `∙ U+2219 BULLET OPERATOR`, but most modern fonts don't make the distinction with `· FA` or `• F7`. (the related codepage ||CP-850@https://en.wikipedia.org/wiki/Code_page_850|| does this too)
- `¤ 00` and `⎕ FF` are control characters in CP-437. they are assigned other characters in vemf (`¤ U+00A4 CURRENCY SIGN` and `⎕ U+2395 APL FUNCTIONAL SYMBOL QUAD` respectively) but (for now) they are syntax errors outside of literals
these are all of the symbols available to vemf programs. even if storing vemf scripts byte-by-byte is more efficient, they use utf-8 by default.
# Execution
a vemf file is a list of statements that are executed in order. there are only a few ways a vemf program can contact with the outside world
the command line arguments are available as `δ` ||Arguments||. as a shorthand, `α` ||Alpha|| and `β` ||Beta|| are set to the first argument and second argument respectively, and `Σ` ||Arity|| is the number of arguments. arguments are always Unicode strings.
the return value of the program (either from a `◘` ||Return|| in the top scope or the last statement in the program) is, by default, formatted and printed automatically. the formatting is the same as `ⁿ0` (see ||Format||):
- if the result is a function, it is called with the arguments passed into the program (monadically with α if only one argument was passed, otherwise with α and β), and then formatted
- if the result is a scalar, it is printed as a number in decimal
- if the result is a flat list, it is printed as a Unicode string, where every element is a codepoint
- if the result is a nested list, each of the inner lists will be printed as a separate line and delimited with newlines
there are also input and output streams. there can be any number, but the cli uses input stream 0 for stdin, output stream 0 for stdout, and output stream 1 for stderr. `☺` ||Print|| and `☻` ||Print Line|| always print text to output stream 0.
the streams are byte streams, and the functions `Ö` ||Write|| and `Ü` ||Read|| convert to/from UTF-8. you may use `_Ö` ||Write Bytes|| and `_Ü` ||Read Bytes|| to manipulate the byte streams directly.
you also have access to a global random number generator (see `á` ||Pick||, `â` ||Sample||, `å` ||Choice||)
---
:char: ☺
:ascii: 'pr
:type: verb
#1 Print
print α to standard output
> "Hello, "☺·"World!◙"☺
see also: ||Print Line||
#2 Print
print α to standard output, and return β
> "Hello, "☺"World!◙"☺
---
:char: ☻
:ascii: '# 'pl
:type: verb
#1 Print Line
print α to standard output, with a training newline (0x0A)
> "Hello, World!"☻
see also: ||Print||, ||Write||
#2 Print Line
print α and return β
> "Calculating the square root of two..."☻2√ ≡ :1.4142135623730951
#_12 Print Formatted
prints `αⁿ` or `αⁿβ` and returns α unchanged. useful when debugging trains. equivalent to `ⁿ╖☻`
---
:char: ♥
:ascii: 'cx
:type: verb
#1 Pairs
split α into pairs, using the fill of α if a pair isn't full. equivalent to `♥2`
> 123456789♥ ≡ (12)(34)(56)(78)(9■)
> 123456789▐1♥ ≡ (12)(34)(56)(78)(91)
> "things"♥ ≡ "th""in""gs"
#2 Chunks
split α into β-sized chunks, using the fill of α if a group isn't full. for scalar β, this is the same as `α↑■β` (see ||Take||):
> 123456789♥3 ≡ (123)(456)(789)
> 123456789♥4 ≡ (1234)(5678)(9■■■)
> 123456789▐0♥4 ≡ (1234)(5678)(9000)
if β is a list, `α♥β` reshapes into groups of `β*` and reshapes them. equivalent to `α↑(■,β)`
> 123456789♥22 ≡ (│12│34)(│56│78)(│9■│■■)
> "chunk brick block"▐` ♥23 ≡ ("chu""nk ")("bri""ck ")("blo""ck ")
---
:char: ♦
:ascii: 'T
:type: verb
#1 Transpose
transpose a nested list. the shape will be the minimum of the lengths of the elements, or `╕~ñ;`
> (123)(456)(789)♦ ≡ (147)(258)(369)
> ("one""two")("three""four")♦ ≡ ("one""three")("two""four")
---
:char: ♣
:ascii: 'dm
:type: verb
#1 Domain
get the domain of a list α, or list of indices. same as `~↕`.
> 1234♣ ≡ 0123
> φ♣ ≡ φ
> (123)(456)(789)♣ ≡ 012
#2 Domain To
get the indices of the elements of a list α, up to a specified depth β.
> (123)(456)(789)♣1 ≡ ♪0♪1♪2
> (123)(456)(789)♣2 ≡ │00│01│02│10│11│12│20│21│22
for rectangular arrays, this is similar to `α▬β↕`. but if the elements have different lengths or depths, this will be reflected in the result:
> "yes""no""maybe"♣2 ≡ │00│01│02│10│11│20│21│22│23│24
> 323"to"(├100├010├001)♣2 ≡ ♪0♪1♪2 │30│31 │40│41│42
> 323"to"(├100├010├001)♣3 ≡ ♪0♪1♪2 │30│31 ├400├401├402├410├411├412├420├421├422
if `β=∞`, this basically returns the indices of all the scalars. this can be a good representation of the shape of an array
> 323"to"(├100├010├001)♣∞ ≡ ♪0♪1♪2 │30│31 ├400├401├402├410├411├412├420├421├422
> 1(2(3(4(5■))))♣∞ ≡ ♪0(10)(110)(1110)(11110)(11111)
---
:char: ♠
:ascii: 'R
:type: verb
#1 Reverse
reverse a list.
> 1234♠ ≡ 4321
> φ♠ ≡ φ
> (123)(456)(789)♠ ≡ (789)(456)(123)
---
:char: •
:ascii: '.
:type: grammar
#n 1-Adverb
the variable `name` with 1-adverb role
> {{αβσμ}}→d 1•d23 ≡ 1 3 2 ■
see also: ||Dyadic Adverb||
---
:char: ◘
:ascii: 'O
:type: statement
#x◘ Return
returns x, breaking out of the enclosing function
> 0{4·5◘6} ≡ 5
see also: ||Discard||, ||Then||
---
:char: ○
:ascii: ',
:type: grammar
#n 2-Adverb
the variable `name` with 2-adverb role
> {{αβσμ}}→d12○d34 ≡ 1 4 3 2
see also: ||Monadic Adverb||
---
:char: ◙
:type: whitespace
#0 Newline
whitespace
---
:char: ♂
:ascii: 'E
:type: verb
#2 Drop
return the list α, with β elements removed from the left. β-pervasive. if β is negative, `β¢` elements are removed from the right instead (see ||Drop Right||). if β is equal or greater than the length, all elements are removed; an empty list is returned.
> "testing"♂3 ≡ "ting"
> "testing"♂_3 ≡ "test"
> "testing"♂9 ≡ φ
#1 Behead
drop 1 element from the left
> "testing"♂ ≡ "esting"
---
:char: ♀
:ascii: 'D
:type: verb
#2 Drop Right
returns the list α, with β elements removed from the right. β-pervasive. if β is negative, `β¢` elements are removed from the left instead (see ||Drop Left||). if β is equal or greater than the length, all elements are removed; an empty list is returned.
> "testing"♀3 ≡ "test"
> "testing"♀_3 ≡ "ting"
> "testing"♀9 ≡ φ
#1 Curtail
drop 1 element from the right
> "testing"♀ ≡ "testin"
---
:char: ♪
:ascii: ':
:type: literal
#♪a Enclosed
for a noun `a`, literal for a list with the one argument. same as `(a♫)`
#♪F Nominalize
for a verb F, interpret it as a noun
---
:char: ♫
:ascii: ';
:type: verb
#1 Enlist
α is enclosed into a single-element list. this is equivalent to `{♪α}`
> 1♫ ≡ ♪1
> 1♫♫♫ ≡ ♪♪♪1
#2 Pair
create a list with the elements α and β. this is equivalent to `{αβ}`. for scalar arguments, this is the same as ||Concatenate||
> 1♫2 ≡ 12
> 1♫2♫3♫4 ≡ ((12)3)4
> 12♫34 ≡ (12)(34)
---
:char: ►
:ascii: 'H
:type: verb
#2 Right
returns β
> 1►2 ≡ 2
#1 Left
returns α
> 1► ≡ 1
---
:char: ◄
:ascii: 'G
:type: verb
#2 Left
returns α
> 1◄2 ≡ 1
#1 Left
returns α
> 1◄ ≡ 1
---
:char: ↕
:ascii: 'I
:type: verb
#1 Iota
when α is a scalar, the output is the range of natural numbers [0, α); starting at 0, excluding α (see ||Inclusive Iota||).
> 5↕ ≡ 01234
> Φ↕ ≡ 0123456789
therefore, `l~↕` is a list of the indices of the list `l` (vemf is 0-indexed), and
> "list"→l l~↕¡l ≡ l
this can also be found as ||Domain||
a negative argument flips the output:
> Φ-↕ ≡ 9876543210
> "list"→l l~-↕¡l ≡ "tsil"
when the argument is a list of scalars, the result will be a nested list that contains the indices of an array of that shape
> 34↕ ≡ │00│01│02│03│10│11│12│13│20│21│22│23
> 123↕ ≡ ├000├001├002├010├011├012
> ♪5↕ ≡ 5↕╕♫
> 15↕ ≡ 5↕╕;0
> 0123↕ ≡ φ
> φ↕ ≡ ♪φ
#2 Range
the range is [α, β)
> 2↕6 ≡ 2345
---
:char: ‼
:ascii: '!
:type: verb
#2 Replicate
it pairs up the elements of α and β, and returns a new list where each element in α is repeated by the corresponding number in β. this can be used as a filter if the elements of β are 0 or 1:
> 12345678‼10101010 ≡ 1357
> 12345678‼110203 ≡ 1244666
> "misisipi"‼11212121 ≡ "mississippi"
replicate also works with scalars and infinite lists
> 12345678‼2 ≡ 1122334455667788
> "cake"‼3 ≡ "cccaaakkkeee"
> "abcdef"‼.► ≡ "bccdddeeeefffff"
if β is longer than α, remaining elements are ignored; if α is longer than β, β's fill is used for the remaining elements
> "abcdef"‼10101 ≡ "ace"
> "abcdef"‼(10101▐1) ≡ "acef"
> "abcdef"‼0101010101 ≡ "bdf"
α's fill is kept for the resulting list. negative elements in β indicate that the fill element will be duplicated instead
> 12345‼12_34 ≡ 122■■■4444
> 12345▐0‼12_34 ≡ 1220004444▐0
Replicate also works with nested lists in β, and it flattens the structure:
> (123)(456)7‼(123)(210)3 ≡ 122333445777
#1 Indices
replicate the ||Domain|| of α (`♣╖‼`). for a boolean list α, this finds the indices of the ones.
> 011010110010‼ ≡ 12467:10
> 10203401‼ ≡ 02244455557
---
:char: ¶
:ascii: '$
:type: verb
#1 Ravel
Ravel flattens all nested lists in α, yielding a list of all the scalars:
> ((01)23)(45(67))(8♪9)¶ ≡ Φ↕
> ♪♪♪♪123¶ ≡ 123
see also: ||Flatten||
#2 Reshape
make a new list with a prefix shape of β, where the elements are taken from α in order. it truncates if α is longer than the elements needed (`β*`), and repeats cyclically through the list if α is shorter
> 6↕¶55 ≡ (01234)(50123)(45012)(34501)(23450)
> :15↕¶33 ≡ (012)(345)(678)
> :9↕¶33 ≡ (012)(345)(678)
> :24↕¶234 ≡ ( (:0:1:2:3)(:4:5:6:7)(:8:9:10:11) )( (:12:13:14:15)(:16:17:18:19)(:20:21:22:23) )
> .►¶33 ≡ (012)(345)(678)
> "testing"¶:21 ≡ "testingtestingtesting"
||Take|| is similar to ||Reshape||, but it does not repeat elements, using the fill instead.
when there is a single ||None|| in β, it will be computed in order to fit all the elements (the ceiling division of the product of the non-||None|| elements of β and the length of α, or `β▀*/(α~)⌠`)
> "testing"¶2■ ≡ "test""ingt"
> "testing"¶■2 ≡ "te""st""in""gt"
see also: ||Take||, ||Take Right||, ||Cycle||
---
:char: §
:ascii: 'ss
:type: verb
#1 Cycle
return α repeated infinitely as an infinite list. more precisely, it returns a function that, given an argument `x`, returns the element of α at index `x % (α~)`
> 4↕§┴¡0123456789 ≡ 0123012301
> 4↕§@_1 ≡ 3
#2 Repeat
repeat the list α, β times. right-pervasive.
> "testing"§3 ≡ "testingtestingtesting"
> 6§3 ≡ 666
---
:char: ▬
:ascii: 'M 'sh
:type: verb
#1 Shape
get the shape of α, that is, the maximum length for each dimension. the output will be a list with fill 1.
> 1▬ ≡ φ▐1
> 123▬ ≡ ♪3▐1
> ((01)23)(45(67)7)(8♪9)▬ ≡ 342▐1
> ♪♪♪♪123▬ ≡ 31111▐1
> ♪♪♪♪(123)▬ ≡ 11113▐1
> (123)(456)(789)▬ ≡ 33▐1
> (1234)(5678)(9012)▬ ≡ 34▐1
> (123)(5678)(90)▬ ≡ 34▐1
see also: ||Length||, ||Depth||
#2 Shape Up To
get only up to a specified depth, without fill.
> (1234)((56)(78))(90)▬  ≡ 342▐1
> (1234)((56)(78))(90)▬4 ≡ 3421
> (1234)((56)(78))(90)▬3 ≡ 342
> (1234)((56)(78))(90)▬2 ≡ 34
> (1234)((56)(78))(90)▬1 ≡ ♪3
---
:char: ↨
:ascii: 'J
:type: verb
#1 Inclusive Iota
when α is a scalar, the output is the range of natural numbers [1, α]; starting at 1, including α.
> 5↨ ≡ 12345
> Φ↨ ≡ 123456789Φ
this is really just ||Iota|| with every item incremented by 1, or `↕▲`.
the extensions that ||Iota|| has, like negative numbers and lists, will also work with Inclusive Iota:
> Φ-↨ ≡ Φ987654321
> 34↨ ≡ │11│12│13│14│21│22│23│24│31│32│33│34
> 123↨ ≡ ├111├112├113├121├122├123
#2 Inclusive Range
the range used is [α, β]. note that this means the resulting array is of length `β-α+1`.
> 2↨8 ≡ 2345678
---
:char: ↑
:ascii: 'W
:type: verb
#2 Take
make a new list with a prefix shape of β, where the elements are taken from α in order. this truncates if α is longer than the elements needed (`β*`), and uses the fill of α if α is shorter.
> 9↕↑55 ≡ (01234)(5678■)(■■■■■)(■■■■■)(■■■■■)
> :99↕↑33 ≡ (012)(345)(678)
> .►↑33 ≡ (012)(345)(678)
> "testing"▐` ↑:21 ≡ "testing              "
> "testing"↑3 ≡ "tes"
||Reshape|| is similar, but it cycles through the array instead of using the fill.
when there is a single ||None|| in β, it will be computed in order to fit all the elements (the ceiling division of the product of the non-||None|| elements of β and the length of α, or `β▀*/(α~)⌠`)
> "testing"▐`_↑2■ ≡ "test""ing_"
> "testing"▐`_↑■2 ≡ "te""st""in""g_"
> "testing"▐`_↑■3 ≡ "tes""tin""g__"
these last cases can be replaced by ||Chunks|| or ||Pairs||:
> "testing"▐`_♥3 ≡ "tes""tin""g__"
> "testing"▐`_♥ ≡ "te""st""in""g_"
see also: ||Reshape||, ||Take Right||, ||Drop||
#1 Prefixes
get the prefixes of the list α; take for every item in `β♣▲` (without the empty list, but with the unmodified argument: you can remove it with ||Behead||.)
> "testing"↑ ≡ "t" "te" "tes" "test" "testi" "testin" "testing"
see also: ||Suffixes||
---
:char: ↓
:ascii: 'S
:type: verb
#2 Take Right
make a new list with a prefix shape of β, where the elements are taken from α in reverse order. this truncates if α is longer than the elements needed (`β*`), and uses the fill of α if α is shorter.
> 9↕↓55 ≡ (■■■■■)(■■■■■)(■■■■■)(■0123)(45678)
> 9↕↓23 ≡ (345)(678)
when there is a single ||None|| in β, it will be computed in order to fit all the elements (the ceiling division of the product of the non-||None|| elements of β and the length of α, or `β▀*/(α~)⌠`)
> "testing"↓3 ≡ "ing"
> "testing"▐` ↓:21 ≡ "              testing"
> "testing"▐`_↓2■ ≡ "_tes""ting"
> "testing"▐`_↓■2 ≡ "_t""es""ti""ng"
see also: ||Take||, ||Reshape||
#1 Suffixes
get the suffixes of the list α; take for every item in `β♣▲` (without the empty list, but with the unmodified argument: you can remove it with ||Curtail||.)
> "testing"↓ ≡ "g" "ng" "ing" "ting" "sting" "esting" "testing"
see also: ||Prefixes||
---
:char: ←
:ascii: 'vr
:type: verb
#1 Get Variable
get the variable with name α
> "_a"← ≡ :12
> `æ→ash "ash"← ≡ `æ
#2 Set Variable
set a new local variable with name α to β
> "ampersand"←`ñ·.ampersand ≡ `ñ
---
:char: →
:ascii: '^
:type: statement
#x→name Set
sets a variable to x in the local scope.
> 2→two .two+.two ≡ 4
if there is nothing in the statement body, the variable will be removed from the local scope.
> 4→a0{5→a →a a} ≡ 4
this is a statement, so verbs can be set conveniently:
> +2→add 3:add ≡ 5
see also: ||Set Function||
---
:char: ∟
:ascii: 'L
:type: verb
#1 Natural Logarithm
get the ||natural logarithm@https://en.m.wikipedia.org/wiki/Natural_logarithm|| of α. scalar.
> 2∟^ ≡ 2
> 1∟ ≡ 0
> 2∟ ≡ :0.6931471805599453
#2 Logarithm
get the ||logarithm@https://en.m.wikipedia.org/wiki/Logarithm|| base β of α. scalar.
> :1000∟Φ ± 3
> Φ√∟Φ ≡ 2/
---
:char: ↔
:ascii: '*
:type: grammar
#x↔name Mutate
mutate a variable in any scope, by applying a function to it monadically. 
> :21→n *3↔n n ≡ :63
this is a statement, so the verb starts where the previous statement ends. this might not work like you might expect it to:
> 3N 4M *2↔n n ≡ 8
because the body of the statement includes ||Set Function||s, which are syntactically verbs:
> (3N4M*2)↔n n ≡ 8    ' 3─n4─m*2 returns 8
> 3→n 4→m *2↔n n ≡ 6  ' but this works
if there is nothing in the statement body, the variable will be removed from its scope.
> 3→n 4→m *2↔n n ≡ 6
> 4→a0{↔a}·a ≡ ■
see also: ||Mutate Function||
---
:char: ▲
:ascii: 'bu
:type: verb
#1 Bump Up
increments the number by 1. equivalent to `+1`. scalar.
> 2▲ ≡ 3
> 0▲▲▲▲▲▲ ≡ 6
> 123▲ ≡ 234
see also: ||Bump Down||, ||Add||
#2 Bins Up
run a binary search. when α is a list sorted in ascending order, it finds the position of the first element in α that is less than or equal to β. you can also think of the list α as intervals of shape [x, y)
> 0259▲6 ≡ 3
> 0259▲Θ0123456789Φ ≡ 011222333344
> "Sample text was first invented in 1894 by James Sample."┴▲"0:" ≡ 2222220222202220222220222222220220111102202222202222220
see also: ||Bins Down||
---
:char: ▼
:ascii: 'bd
:type: verb
#1 Bump Down
decrements the number by 1. equivalent to `-1`. scalar.
> 3▼ ≡ 2
> 0▼▼▼▼▼▼ ≡ _6
> 123▼ ≡ 012
see also: ||Bump Up||, ||Subtract||
#2 Bins Down
run a binary search. when α is a list sorted in descending order, it finds the position of the first element in α that is greater than or equal to β.
> :18:13:8▼:20 ≡ 0
> :18:13:8▼:18 ≡ 0
> :18:13:8▼:15 ≡ 1
> :18:13:8▼:12 ≡ 2
> :18:13:8▼:2 ≡ 3
see also: ||Bins Up||
---
:char:  
:type: whitespace
#&nbsp; Space
whitespace. may change the parsing of some tokens:
> ¨things  ≡ "things"
> ¨thing s ≡ "thing"s
> :2022  ≡ (:2022)
> :202 2 ≡ (:202)(2)
---
:char: !
:type: verb
#1 Factorial
get the factorial of α. this is extended to reals with the ||Gamma function@https://en.wikipedia.org/wiki/Gamma_function||, Γ(α + 1). scalar.
> 0! ≡ 1
> 1! ≡ 1
> 3! ≡ 6
> 4! ≡ :24
> 5! ≡ :120
> 7! ≡ :5040
> Φ! ≡ :3628800
> :-0.5! ± π√
#2 Permute
number of β-permutations in α items. also known as the ||falling factorial@https://en.wikipedia.org/wiki/Falling_and_rising_factorials||, descending factorial, pochhammer symbol, or the nPr key in your calculator. equivalent to `-╓!║/` or `{α!/(α-β!)}`. scalar.
> 1!1 ≡ 1
> 3!2 ≡ :6
> 4!3 ≡ :24
> 8!3 ≡ :336
---
:char: "
:type: literal
#"abcd" Quotes
string literal; every character until the next `"` will be put into a list with ||None|| fill
> "" ≡ φ
> "a" ≡ ♪`a
> "abc" ≡ `a`b`c
this uses the codepage codepoints:
> "☺☻♥♦" ≡ 1234
with some special characters used specially: `¨` stands for `"` (0x22) and `·` stands for `'` (0x27). `'` may be used for escaping these:
> "he said ¨hi¨"   ≡ "he said ",`","hi",`"
> "umlaut ─ '¨ ← diaeresis" ≡ "umlaut ─ ",`¨," ← diaeresis"
---
:char: #
:type: verb
#1 First True
find the first non-0 value and return its index, or else ||None||.
> 10101010# ≡ 0
> 0001010# ≡ 3
> 00002010# ≡ 4
> 0000000# ≡ ■
#2 Index Of
find the first exact match in the list and return its index, or else ||None||. β-pervasive.
> "hello"#`l ≡ 2
> "abcdefghijklmnopqrs"#"beeimpostor" ≡ :1:4:4:8:12:15:14:18■:14:17
> 012073167140#0123456789 ≡ 0125Φ■74■■
---
:char: $
:type: verb
#1 Call with None
calls the function α with ||None|| as an argument
> .♫$ ≡ ♪■
#2 Call
calls the function α with `β@0` and `β@1` (only if `β~ ≥ 2`) as arguments.
> .+$23 ≡ 5
> .+$234 ≡ 5
> .-$2 ≡ _2
> .♫$24 ≡ 24
---
:char: %
:type: verb
#1 Power of Two
calculate 2 to the power of α. equivalent to `┴^2`. scalar.
> 0% ≡ 1
> 4% ≡ :16
> :32% ≡ :4294967296
#2 Modulo
returns the ||modulo@https://en.m.wikipedia.org/wiki/Modulo|| of α divided by β, also known as the remaider. scalar.
> 7%5 ≡ 2
> 2%5 ≡ 2
> _3%5 ≡ 2
> 4%0 ≡ ■
> :20↕%3 ≡ 0120120120 1201201201
> :20↕-9└÷♫%3≡(_3_3_3_2_2_2ΘΘΘ00011122233)(01201201201201201201) ≡ 1
this is euclidean modulo; it always gives a positive result such that `β*(a÷β) + (α%β) ≡ α`.
> 1%2 ≡ 1
> 1%_2 ≡ 1
> _1%2 ≡ 1
> _1%_2 ≡ 1
---
:char: &
:type: verb
#2 And
compute boolean AND of α and β. return 1 if both α and β are nonzero, otherwise 0. scalar.
> 0&0 ≡ 0
> 0&1 ≡ 0
> 1&0 ≡ 0
> 1&1 ≡ 1
> 2&2 ≡ 1
see also: ||Or||, ||Maximum||
#1 All
return 1 if all the items in α are non-zero. equivalent to `╧&1`
> 0110101010& ≡ 0
> 1111111111& ≡ 1
> 1273981913& ≡ 1
for an empty list, this is always 1:
> φ& ≡ 1
see also: ||And||, ||Any||
---
:char: '
:type: literal
#'A,'ab Escape
escapes are one way to write characters outside the ascii range (characters in the range 0x20 ` ` to 0x7E `~`, the ones that you almost certainly have in your keyboard). you will see the escapes in the documentation of each character.
there are more non-ascii characters than ascii characters in the codepage (256 − 95 = 161), so some characters need two character escape sequences. these start with a lowercase letter [`a`, `z`].
the characters with single character escape sequences are the following:
> !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`{|}~
> ‼╕☻¶÷·'╙╜↔±○¬•╧╣┘│├╞╟╠┤╡╢♪♫≤≡≥¿¡αβ¢♀♂ƒ◄►↕↨└∟▬■◘╨Θ♠↓♦╩√↑Φ¥φ╓╤╖→⌐┴╘┬╛≈
#'&#x20;abc Line Comment
all of the characters until the next line break will be ignored.
---
:char: (
:type: grammar
#(x) Opening Parenthesis
groups multiple words in a single noun. often used to change verb or adverb precedence,
> 1+2*3 ≡ 9
> 1+(2*3) ≡ 7
or to group elements in a strand or train,
> (123)(456)(789)@0 ≡ 123
> 001334(û¬)╓‼ ≡ 0134
often, you won't need to close a parenthesis, like in the end of a file or a statement
> 1+(2*3→seven .seven*2 ≡ :14
parentheses can be thought of having less precedence than braces `{}`
> :15{"number ",(αª} ≡ "number 15"
if there arent many words inside the parenthesis, ||Grouping|| may be used instead
> ├123├456├789@0 ≡ 123
> 001334│û¬╓‼ ≡ 0134
an empty parenthesis is the same as ||Empty List||
> () ≡ φ
---
:char: )
:type: grammar
#(x) Closing Parenthesis
closing counterpart of ||Opening Parenthesis||.
---
:char: *
:type: verb
#2 Multiply
calculate α × β. scalar.
> 3*3 ≡ 9
> 2*3 ≡ 6
> 4*4 ≡ :16
> `a*`b ≡ `b*`a
#1 Product
multiply all the items in α. equivalent to `╧*`.
> 234* ≡ :24
> 2222* ≡ :16
> (123)(456)(789)* ≡ :28:80:162
> (123)(456)(789)** ≡ :362880  ' 9!
the empty product is the multiplicative identity, 1.
> φ* ≡ 1
see also: ||Reduce||, ||Sum||
---
:char: +
:type: verb
#2 Add
calculate α + β. scalar.
> 3+2 ≡ 5
> 4+3 ≡ 7
> `a+`b ≡ `b+`a
#1 Sum
add all the items in α. equivalent to `╧+`.
> 1234+ ≡ :10
> (123)(456)(789)+ ≡ :12:15:18
> (123)(456)(789)++ ≡ :45
the empty sum is the additive identity, 0.
> φ+ ≡ 0
see also: ||Reduce||, ||Product||
---
:char: ,
:type: verb
#1 Flatten
same as ||Reduce|| ||Concatenate|| `╧,`. this removes one level of nesting in α.
> ¨foo¨bar¨bash, ≡ "foobarbash"
> (012)(34(567))(89), ≡ 01234(567)89
this returns ||None|| for empty lists:
> φ, ≡ φ
see also: ||Reshape||
#2 Concatenate
concatenate the two lists α and β
> 123,456 ≡ 123456
> "Hello,"," world" ≡ "Hello, world"
a scalar argument is used as a 1-argument list:
> 1,1 ≡ 11
> 12,3 ≡ 123
> 1,23 ≡ 123
> 1,2,3 ≡ 123
see also: ||Pair||, ||Append||, ||Prepend||
---
:char: -
:type: verb
#1 Negate
calculate −α. scalar
> 1- ≡ :-1
> Φ- ≡ :-10
> 2--2 ≡ _4
> 123- ≡ _1_2_3
> 3-- ≡ 3
#2 Subtract
calculate α − β. scalar
> 3-2 ≡ 1
> 4-1 ≡ 3
> 3-0 ≡ 3
---
:char: .
:type: grammar
#n Noun
the variable `name` with noun role.
if not defined, will return ||None||.
> .kjfghkjbgihjbhekjgerbn ≡ ■
see also: ||Set||, ||Mutate||
---
:char: /
:type: verb
#1 Reciprocal
get the reciprocal of α, or 1/α. scalar
> 6/ ≡ 1/6
> 8/ ≡ :0.125
#2 Divide
calculate α / β. scalar
> 6/2 ≡ 3
> 6/3 ≡ 2
> 0/0 ≡ ■
---
:char: 0
:type: noun
#0 Zero
the integer 0
#.0 
the number `0.01`, or `:100/`
---
:char: 1
:type: noun
#0 One
the integer 1
#_0 Minus One
the integer −1
#.0 
the number `0.1`, or `Φ/`
---
:char: 2
:type: noun
#0 Two
the integer 2
#_0 Minus Two
the integer −2
#.0
the number `0.2`, or `5/`
---
:char: 3
:type: noun
#0 Three
the integer 3
#_0 Minus Three
the integer −3
#.0
the number `0.3`, or `3/Φ`
---
:char: 4
:type: noun
#0 Four
the integer 4
#_0 Minus Four
the integer −4
#.0
the number `0.4`, or `2/5`
---
:char: 5
:type: noun
#0 Five
the integer 5
#_0 Minus Five
the integer −5
#.0
the number `0.5`, or `5/Φ`
---
:char: 6
:type: noun
#0 Six
the integer 6
#_0 Minus Six
the integer −6
#.0
the number `0.6`, or `3/5`
---
:char: 7
:type: noun
#0 Seven
the integer 7
#_0 Minus Seven
the integer −7
#.0
the number `0.7`, or `7/Φ`
---
:char: 8
:type: noun
#0 Eight
the integer 8
#_0 Minus Eight
the integer −8
#.0
the number `0.8`, or `4/5`
---
:char: 9
:type: noun
#0 Nine
the integer 9
#_0 Minus Nine
the integer −9
#.0
the number `0.9`, or `9/Φ`
---
:char: :
:type: grammar
#n Verb
the variable `name` with verb role
#:123 Numeric Literal
when the character after the colon is a decimal digit `[0-9]` or the negative sign `-`, it will be interpreted as a number (integer or floating point).
> :12 ≡ Φ+2
> :39 ≡ 3*Φ+9
> :256 ≡ 2^8
> :-3 ≡ _3
> :12:24:32/4 ≡ 368
this also supports decimals, with a decimal point `.` or ||scientific notation@https://en.wikipedia.org/wiki/Scientific_notation|| using `e`:
> :43.21 ≡ :4321/:100
> :6.022e23 ≈ :6.022*(Φ^:23)
> :1.6605e−27 ≈ :1.6605/(Φ^:27)
> :0.01 ≡ 1/:100
> :1e-2 ≡ 1/:100
this syntax allows for `0x` `0b` `0o` `0s` `0z` `0n` for hexadecimal, binary, octal, senary, duodecimal, hexatrigesimal respectively. these use the digits `0-9` and `a-z` (always in lowercase):
> :0xff ≡ :255
> :0xdeadbeef ≡ :3735928559
> :-0nxyz ≡ :-44027
> :0x100000000 ≡ 2^:32
the syntax looks a bit like this:
> number := ":" "-"? (decimal | based)
> decimal := [0-9]+ ("." [0-9]*)? ("e" "-"? [0-9]+)?
> based := "0x" [0-9a-f]*
>        | "0b" [0-1]*
>        | "0o" [0-7]*
>        | "0s" [0-5]*
>        | "0z" [0-9a-b]*
>        | "0n" [0-9a-z]*
note that whitespace ends a literal:
> :1 234 ≡ (1)(2)(3)(4)
> :12 34 ≡ (:12)(3)(4)
> :123 4 ≡ (:123)(4)
> :1234  ≡ :1234
see also: ||Integer Literals||
---
:char: ;
:type: verb
#1 Duplicate
forms a pair `αα`. same as `┴♫`
> 5; ≡ 55
> 123; ≡ (123)(123)
#2 Procatenate
concatenates β to α. same as `┴,`
> 5;4;3 ≡ 345
> 123;456 ≡ 456123
---
:char: <
:type: verb
#1 Grade Up
Grade Up can be used for sorting. it returns a permutation, or list of indices, that would sort the list descendingly. you can think of this as sorting the array `α~↕` according to α
> 37625< ≡ 30421
> 37625<¡37625 ≡ 23567
> 37625<╖¡ ≡ 23567  ' more tacit
this uses stable sorting: the same array will always yield the same permutation, and equal arguments are ordered by position.
see also: ||Grade Down||, ||Sort Up||
#2 Less Than
return 1 if α < β, else 0. scalar.
> 5<3 ≡ 0
> 3<3 ≡ 0
> 3<5 ≡ 1
see also: ||Greater Than||
#_2 Lexicographic Less Than
return 1 if α < β, else 0. this function is not scalar; if any of the two elements are lists, it will compare lexicographically:
> 234_<235 ≡ 1
> 234_<233 ≡ 0
> 234_<263 ≡ 1
> 334_<263 ≡ 0
if both lists don't have the same length, the extra items are compared with the smaller's list fill. the default fill is ||None||, and ||None|| is less than every other value, so a list is greater than its prefixes:
> "cat"_<"catnip" ≡ 1
> "cat"▐`z_<"catnip" ≡ 0
see also: ||Lexicographic Greater Than||
---
:char: =
:type: verb
#1 Depth
get the depth of the deepest element in α. same as `▬~`
> 1= ≡ 0
> 123= ≡ 1
> ((01)23)(45(67)7)(8♪9)= ≡ 3
> ♪♪♪♪123= ≡ 5
> ♪♪♪♪(123)= ≡ 5
> (123)(456)(789)= ≡ 2
> (1234)(5678)(9012)= ≡ 2
> (123)(5678)(90)= ≡ 2
> (1234)((56)(78))(90)= ≡ 3
see also: ||Shape||
#2 Equals
return 1 if α = β, else 0. scalar.
> 5=3 ≡ 0
> 3=3 ≡ 1
> 3=5 ≡ 0
> 123454321234=2 ≡ 010000010100
> "words words words"=`  ≡ 00000100000100000
two NaNs compare equal:
> ■=■ ≡ 1
see also: ||Matches||, ||Not Equals||
---
:char: >
:type: verb
#1 Grade Down
Grade Down can be used for sorting. it returns a permutation, or list of indices, that would sort the list descendingly. you can think of this as sorting the array `α♣-` according to α.
> 37625> ≡ 12403
> 37625>¡37625 ≡ 76532
> 37625>╖¡ ≡ 76532  ' more tacit
this uses stable sorting: the same array will always yield the same permutation, and equal arguments are ordered by position.
see also: ||Grade Up||, ||Sort Down||
#2 Greater Than
return 1 if α > b, else 0. scalar.
> 5>3 ≡ 1
> 3>3 ≡ 0
> 3>5 ≡ 0
see also: ||Less Than||
#_2 Lexicographic Greater Than
return 1 if α < β, else 0. this function is not scalar; if any of the two elements are lists, it will compare lexicographically:
> 234_>235 ≡ 0
> 234_>233 ≡ 1
> 234_>263 ≡ 0
> 334_>263 ≡ 1
if both lists don't have the same length, the extra items are compared with the smaller's list fill. the default fill is ||None||, and ||None|| is less than every other value, so a list is greater than its prefixes:
> "cat"_>"catnip" ≡ 0
> "cat"▐`z_>"catnip" ≡ 1
see also: ||Lexicographic Less Than||
---
:char: ?
:type: statement
#x?y Then
execute statement y if x is not 0 or ||Null||. if x is a function, it will be called with α and, if `Σ~1`, β.
> _3→b b<0?-↔b b ≡ 3
>  5→b b<0?-↔b b ≡ 5
||Return|| may be used for short-circuiting. this is the same as your familiar ternary statement.
> _3{<0?α-◘α} ≡ 3
>  5{<0?α-◘α} ≡ 5
> 5→a[a<0?a-◘a] ≡ 5
---
:char: @
:type: verb
#1 First
get the first item in a list α. this is equivalent to calling α with 0.
> "aeiou"@ ≡ `a
> (12)(34)@ ≡ 12
> (+2)@ ≡ 2
#2 Index
get the element in list α at index β
> "aeiou"@2 ≡ `i
> 4321@1 ≡ 3
> (12)(34)(56)(78)@2 ≡ 56
if α is a function, it will be called with the index:
> (-)@3 ≡ _3
> (*3-2)@5 ≡ :13
> (♠)@"bee" ≡ "eeb"
if the index is outside the list's domain [0, α~), or if it is null, it uses its fill
> 123@5 ≡ ■
> 123▐0@5 ≡ 0
> 123▐0@■ ≡ 0
when α and β are lists, this indexes at depth, so that `l@20 ≡ l@2@0`
> (12)(34)(56)(78)@20 ≡ 5
> (12)(34)(56)(78)@21 ≡ 6
> (+3)(-2)(½)(÷8)@27 ≡ :3.5
in this case, null selects all the items. this can be useful for retrieving columns of a matrix
> 123@♪■ ≡ 123
> (12)(34)(56)(78)@2■ ≡ 56
> (12)(34)(56)(78)@■1 ≡ 2468
> (123)(456)(789)@1■ ≡ 456
> (123)(456)(789)@■1 ≡ 258
> (123)(456)(789)@■2 ≡ 369
---
:char: A
:type: verb_variable
#12
general-purpose verb variable. by default, `─a`.
#_0
the string `"ABCDEFGHIJKLMNOPQRSTUVWXYZ"`
---
:char: B
:type: verb_variable
#12
general-purpose verb variable. by default, `─b`.
#_0
the string `"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"`
---
:char: C
:type: verb_variable
#12
general-purpose verb variable. by default, `─c`.
#_0
the string `"abcdefghijklmnopqrstuvwxyz"`
---
:char: D
:type: verb_variable
#12
general-purpose verb variable. by default, `─d`.
#_0
the string `"0123456789"`
---
:char: E
:type: verb_variable
#12
general-purpose verb variable. by default, `─e`.
#_0
the string `"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"`
---
:char: F
:type: verb_variable
#12
general-purpose verb variable. by default, `─f`.
#_0
the string `"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"`
---
:char: G
:type: verb_variable
#12
general-purpose verb variable. by default, `─g`.
#_0
the string `"0123456789abcdefghijklmnopqrstuvwxyz"`
---
:char: H
:type: verb_variable
#12
general-purpose verb variable. by default, `─h`.
#_0
the string `"0123456789ABCDEF"`
---
:char: I
:type: verb_variable
#12
general-purpose verb variable. by default, `─i`.
#_0
the string `"0123456789abcdef"`
---
:char: J
:type: verb_variable
#12
general-purpose verb variable. by default, `─j`.
#_0
the string `"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"`
---
:char: K
:type: verb_variable
#12
general-purpose verb variable. by default, `─k`.
---
:char: L
:type: verb_variable
#12
general-purpose verb variable. by default, `─l`.
---
:char: M
:type: verb_variable
#12
general-purpose verb variable. by default, `─m`.
---
:char: N
:type: verb_variable
#12
general-purpose verb variable. by default, `─n`.
---
:char: O
:type: verb_variable
#12
general-purpose verb variable. by default, `─o`.
---
:char: P
:type: verb_variable
#12
general-purpose verb variable. by default, `─p`.
---
:char: Q
:type: verb_variable
#12
general-purpose verb variable. by default, `─q`.
---
:char: R
:type: verb_variable
#12
general-purpose verb variable. by default, `─r`.
---
:char: S
:type: verb_variable
#12
general-purpose verb variable. by default, `─s`.
---
:char: T
:type: verb_variable
#12
general-purpose verb variable. by default, `─t`.
---
:char: U
:type: verb_variable
#12
general-purpose verb variable. by default, `─u`.
---
:char: V
:type: verb_variable
#12
general-purpose verb variable. by default, `─v`.
---
:char: W
:type: verb_variable
#12
general-purpose verb variable. by default, `─w`.
---
:char: X
:type: verb_variable
#12
general-purpose verb variable. by default, `─x`.
---
:char: Y
:type: verb_variable
#12
general-purpose verb variable. by default, `─y`.
---
:char: Z
:type: verb_variable
#12
general-purpose verb variable. by default, `─z`.
---
:char: [
:type: grammar
#[abc] Start Block
list of statements that are executed until a ||Return|| or the end is found, and return that value. similar to a ||Define Function||, but it is immediately executed and doesn't have a scope. most useful with `?` ||Then||, as it can be used to simulate a ternary operator:
> 6→a a%3=0?[/3↔a "a is now ",(aⁿ] ≡ "a is now 2"
> [1+1=2?"yay"◘"oh no"]Ç ≡ "YAY"
---
:char: \
:type: verb
#1 Filter Holes
remove ||None||s in the list α.
> ■12■345■■67■89\ ≡ 123456789
#2 Set Difference
return α without the items in β
> "hello world i am a vemf test"\`  ≡ "helloworldiamavemftest"
> "hello world i am a vemf test"\¨aeiou ≡ "hll wrld  m  vmf tst"
---
:char: ]
:type: grammar
#[abc] End Block
closing counterpart of `[` ||Start Block||.
---
:char: ^
:type: verb
#1 Exponential
calculate ||exp α@https://en.wikipedia.org/wiki/Exponential_function||, or e^α, where e is Euler's number. scalar.
> 1^ ≡ :2.718281828459045
> 3^ ≡ :20.085536923187668
#2 Exponent
calculate ||α raised to the power of β@https://en.wikipedia.org/wiki/Exponentiation||. scalar.
> 2^6 ≡ :64
> 3^5 ≡ :243
---
:char: _
:type: grammar
#&#x5f;a Alternate
the underscore is used for accessing variant forms of functions or variables. `_a` is equivalent to `."_a"`, `:"_a"`, `•"_a"` or `○"_a"` depending on the rank of `a`
for numbers (`123456789Φ`), this will be its negative:
> _1_2_3_4_5_6_7_8_9_Φ ≡ 123456789Φ-
uppercase ascii letters (`A`-`Z`) store convenient constants:
> _A ≡ "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
> _B ≡ "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
> _C ≡ "abcdefghijklmnopqrstuvwxyz"
> _D ≡ "0123456789"
> _E ≡ "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
> _F ≡ "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
> _G ≡ "0123456789abcdefghijklmnopqrstuvwxyz"
> _H ≡ "0123456789ABCDEF"
> _I ≡ "0123456789abcdef"
> _J ≡ "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
> _K ≡ "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
---
:char: `
:type: literal
#`a Character Literal
the position of `a` in the codepage
> `a ≡ :97
> `b ≡ :98
> `⌡ ≡ :245
see also: ||Digraph Literal||
---
:char: a
:type: variable
#0
a general-purpose variable. by default, 12
---
:char: b
:type: variable
#0
a general-purpose variable. by default, 20
---
:char: c
:type: variable
#0
a general-purpose variable. by default, 99
---
:char: d
:type: variable
#0
a general-purpose variable. by default, 100
---
:char: e
:type: variable
#0
a general-purpose variable. by default, 999
---
:char: f
:type: variable
#0
a general-purpose variable. by default, 1000
---
:char: g
:type: variable
#0
a general-purpose variable. by default, 10000
---
:char: h
:type: variable
#0
a general-purpose variable. by default, 100000
---
:char: i
:type: variable
#0
a general-purpose variable. by default, 1000000
---
:char: j
:type: variable
#0
a general-purpose variable. by default, 10000000
---
:char: k
:type: variable
#0
a general-purpose variable. by default, 15
---
:char: l
:type: variable
#0
a general-purpose variable. by default, 16
---
:char: m
:type: variable
#0
a general-purpose variable. by default, 31
---
:char: n
:type: variable
#0
a general-purpose variable. by default, 32
---
:char: o
:type: variable
#0
a general-purpose variable. by default, 63
---
:char: p
:type: variable
#0
a general-purpose variable. by default, 64
---
:char: q
:type: variable
#0
a general-purpose variable. by default, 127
---
:char: r
:type: variable
#0
a general-purpose variable. by default, 128
---
:char: s
:type: variable
#0
a general-purpose variable. by default, 255
---
:char: t
:type: variable
#0
a general-purpose variable. by default, 256
---
:char: u
:type: variable
#0
a general-purpose variable. by default, 512
---
:char: v
:type: variable
#0
a general-purpose variable. by default, 1024
---
:char: w
:type: variable
#0
a general-purpose variable. by default, 32768
---
:char: x
:type: variable
#0
a general-purpose variable. by default, 65536
---
:char: y
:type: variable
#0
a general-purpose variable. by default, 16777216, or `2^:24`
---
:char: z
:type: variable
#0
a general-purpose variable. by default, 2147483648, or `2^:31`
---
:char: {
:type: grammar
#{abc} Define Function
return a function that executes the statements inside the braces, returning a value and stopping once a ||Return|| statement is hit. a ||Return|| statement is implicit at the end of a function. this function will have a role of verb.
> {"Hello, World!"☻·}→sayhi 0:sayhi ≡ ■
> {6á▲◘}→roll 0:roll ?≡ 4
> {6á▲}→roll 0:roll ?≡ 4
some variables are set when calling a function: `α` ||Alpha|| is set to the left argument, `β` ||Beta|| is set to the right argument or ||None|| if not given, `ƒ` ||Self|| to the function being called, and `Σ` ||Arity|| to the number of arguments passed.
> {α+β/2}→avg 3:avg7 ≡ 5
the inside of a function creates a scope, and any variables created inside the scope will not be visible once the function returns.
> 123{α*2→double .double-1} ≡ 135
> 123{α*2→double .double-1}· .double ≡ ■
when a function is created, all of the variables that it references as a value will be captured (lexical scope). this capture is immutable; if you change the value of a capture, it will only be changed in that function's scope.
> 123→l{l,α↔l}→append 4:append· l ≡ 123
there are two ways of changing this, both equivalent: not referencing the value (as ||Mutate Statement|| can take a function), or deleting the capture. then it will look for an `l` in the caller scope (dynamic scope); the variable you reference must be in scope and there must not be any other variable with the same name in the same scope.
> 123→l{,α↔l}→append 4:append· l ≡ 1234
> 123→l{→l l,α↔l}→append 4:append· l ≡ 1234
> 123→l{,α↔l}→append 0{"things"→l 4:append· l} ≡ "things♦"  ' oops!
the braces don't need to be closed at the end of file.
---
:char: |
:type: verb
#2 Or
compute boolean OR of α and β; return 1 if one of α and β are nonzero, otherwise 0. scalar.
> 0|0 ≡ 0
> 0|1 ≡ 1
> 1|0 ≡ 1
> 1|1 ≡ 1
see also: ||And||, ||Minimum||
#1 Any
return 1 if any item in α is nonzero. equivalent to `╧&#x7C;0`
> 10101011101| ≡ 1
> 11111111111| ≡ 1
> 00000000000| ≡ 0
for an empty list, this is always 0:
> φ| ≡ 0
see also: ||Or||, ||All||
---
:char: }
:type: grammar
#{abc} End Function
closing counterpart of ||Define Function||.
---
:char: ~
:type: verb
#1 Length
get the length of α. equivalent to `▬@`.
> 1111~ ≡ 4
> (12)(34)(56)~ ≡ 3
> φ~ ≡ 0
scalars have a length of 1, and functions have a length of ||Infinity||.
> 3~ ≡ 1
> .►~ ≡ ∞
see also: ||Shape||, ||Depth||
#2 Not Equals
same as `=¬`. scalar.
> 5~3 ≡ 1
> 3~3 ≡ 0
> 3~5 ≡ 1
see also: ||Equals||, ||Not Matches||
---
:char: ⌂
:ascii: 'ex
:type: verb
#1 Exit
exits the program. if α is an integer, it will be the return code; otherwise, α will be printed as a string before exiting.
---
:char: Ç
:ascii: 'c+
:type: verb
#1 Uppercase
returns α, uppercasing it if in the range 'a'..'z'. scalar.
> "UPPERCASE"Ç ≡ "UPPERCASE"
> "lowercase"Ç ≡ "LOWERCASE"
> "Bees, bees"Ç ≡ "BEES, BEES"
> "mOcKiNg"Ç ≡ "MOCKING"
see also: ||Lowercase||
---
:char: ü
:ascii: 'u"
:type: verb
#1 Complex Conjugate
returns α, changing the sign of the imaginary part
> 2í3ü ≡ _2í3
> Θí4ü ≡ 1í4
> 2ü ≡ 2
#2 Group
pair up the elements of α and β, and returns a new list where each element in α appears in the βth element, in order. the fill will be the ||Empty List||. if β is ||None||, the element will be ignored.
> "vemf programming language"ü0000■11111112222■33333333 ≡ "vemf""program""ming""language"▐φ
> 123456789ü012012012 ≡ (147)(258)(369)▐φ
> "bee bumblebee honeybee"ü000φ111111000φ11111000 ≡ "beebeebee""bumblehoney"▐φ
> "eastern bumblehoneybee"ü2222222211111122222(012)(012)(012) ≡ "bee""bumblebee""eastern honeybee"▐φ
---
:char: é
:ascii: 'e'
:type: verb
#1 Bits
get the internal representation of the integer α. this will be a 64-element list of bits with fill 0. scalar.
> :3054é ≡ 0000000000000000000000000000000000000000000000000000101111101110▐0
#2 Encode Base
encodes the number α into the base β as a list, without any trailing zeros and 0 fill. scalar.
> :314éΦ ≡ 314▐0
> :1000éΦ ≡ 1000▐0
> :314é2 ≡ 100111010▐0
> 0é3 ≡ φ▐0
> :16↕é4╛↓2 ≡ │00│01│02│03│10│11│12│13│20│21│22│23│30│31│32│33
see also: ||Represent Base||, ||Decode Base||
---
:char: â
:ascii: 'a^
:type: verb
#1 Tangent
calculate `tan α`. scalar.
> 0â ± 0
> π/6â ± 3√/3
> π/4â ± 1
> π/3â ± 3√
> π/2â ± ■
> πâ ± 0
> π*3½â ± ■
> π*2â ± 0
#2 Bitwise And
calculate bitwise AND of integers α and β. scalar.
> (0011è)â(0101è) ≡ 0001è
> :3054â:255 ≡ :238
---
:char: ä
:ascii: 'a"
:type: verb
#1 Arctangent
calculate `arctan α` or `tan⁻¹ α`. scalar.
> 0ä ± 0
> 3√ä ± π/3
> 1ä ± π/4
#2 Nand
calculate boolean NAND of α and β. scalar. equivalent to `&¬`
> 0ä0 ≡ 1
> 0ä1 ≡ 1
> 1ä0 ≡ 1
> 1ä1 ≡ 0
---
:char: à
:ascii: 'a`
:type: verb
#2 Sample
get a simple random sample of the list α of length β; that is, take β distinct elements randomly from α.
> "sample"à4 ?≡ "smae"
> "sample"à4 ?≡ "esal"
> "sample"à2 ?≡ "em"
if β is the length of α, this is effectively a shuffle, which is what à does monadically:
> "sample"à6 ?≡ "mpesla"
#1 Shuffle
shuffle the elements from α
> "sample"à ?≡ "lspeam"
---
:char: å
:ascii: 'ao
:type: verb
#1 Choice
pick a random element in α
> "pick"å ?≡ `c
> "pick"å ?≡ `k
#2 Choices
pick β elements from α, putting them in a list. β-pervasive.
> "pick"å3 ?≡ "ikk"
> "pick"åΦ ?≡ "ikcipckikc"
these might repeat; see ||Sample||
---
:char: ç
:ascii: 'c,
:type: verb
#1 Lowercase
return α, lowercasing it if in the range 'A'..'Z'. scalar.
> `Aç ≡ `a
> "UPPERCASE"ç ≡ "uppercase"
> "lowercase"ç ≡ "lowercase"
> "Bees, bees"ç ≡ "bees, bees"
> "mOcKiNg"ç ≡ "mocking"
see also: ||Uppercase||
---
:char: ê
:ascii: 'e^
:type: verb
#1 Encode Codepage
convert Unicode codepoint α into the vemf codepage, or ||None|| if not possible. scalar.
> :8226:9829:9786:402`eê ≡ "•♥☺ƒe"
#2 Encode
represent α in the radix system β in big-endian order. α-pervasive. we can use this, for example, for converting to hours, minutes, and seconds:
>   :4000ê:24:60:60 ≡ :0:1:6:40
>   :3200ê:24:60:60 ≡ :0:0:53:20
> :140000ê:24:60:60 ≡ :1:14:53:20
note that the result has one more item than β for the remainder. you can remove it with ||Behead|| if you want
> :12345êΦΦΦΦΦΦ♂ ≡ 012345
> :1234567êΦΦΦΦΦΦ♂ ≡ 234567
encode is also useful as a divmod
> :123.45ê:10 ± :12:3.45
> :123.45ê1 ± :123:0.45
#_1 Encode UTF-8
represent a string as a UTF-8 list of bytes, converting invalid values to � U+FFFD REPLACEMENT CHARACTER.
> `a:269:676:1062:8224:30340:128238:69685_ê ≡ "a─ì╩ñ╨ªΓÇáτÜä≡ƒô«≡æÇ╡"
---
:char: ë
:ascii: 'e"
:type: verb
#1 Decode Codepage
convert characters from vemf codepage into Unicode, or ||None|| if not possible. scalar.
> "•♥☺ƒe"ë ≡ :8226:9829:9786:402`e
#2 Decode
decode α from the radix system β in big-endian order. this is an inverse of ||Encode||
> 0:1:6:40ë:24:60:60 ≡ :4000
> :1:6:40ë:24:60:60 ≡ :4000
> :12:3.45ë:10 ± :123.45
> :123:0.45ë1 ± :123.45
#_1 Decode UTF-8
converts a list of bytes into a string, converting invalid sequences to � U+FFFD REPLACEMENT CHARACTER.
> "a─ì╩ñ╨ªΓÇáτÜä≡ƒô«≡æÇ╡"_ë ≡ `a:269:676:1062:8224:30340:128238:69685
---
:char: è
:ascii: 'e`
:type: verb
#2 Decode Base
converts a list α from positional base β, in little-endian order. β-pervasive.
> 3054èΦ ≡ :3054
see also: ||Encode Base||, ||Parse Base||
#1 Decode Binary
use 2 as the base
> 0101è ≡ 5
> 101111101110è2 ≡ :3054
---
:char: ï
:ascii: 'i"
:type: verb
#1 Arcsine
calculate `arcsin α` or `sin⁻¹ α`. scalar.
> Θï ± π½-
> 0ï ± 0
> 1ï ± π½
#2 Xor
calculate boolean XOR of α and β. scalar. equivalent to `⌐║~`
> 0ï0 ≡ 0
> 0ï1 ≡ 1
> 1ï0 ≡ 1
> 1ï1 ≡ 0
---
:char: î
:ascii: 'i^
:type: verb
#1 Sine
calculate `sin α`. scalar.
> 0î ± 0
> π/6î ± 1½
> π/4î ± 2√½
> π/3î ± 3√½
> π/2î ± 1
> πî ± 0
> π*3½î ± Θ
> π*2î ± 0
#2 Bitwise Xor
calculate bitwise XOR of α and β. scalar.
> (0011è)î(0101è) ≡ 0110è
> :3054î8 ≡ :3046
---
:char: ì
:ascii: 'i`
:type: verb
#1 Cis
calculate `cis α` or `exp(i*α)`. scalar.
> 0ì ± 1
> π½ì ± 1í
> πì ± Θ
> π-½ì ± Θí
#2 From Polar
calculate `β * cis α` or `β*exp(i*α)`. this is the same as converting from the polar form where `α = φ` (the argument) and `β = r` (the modulus or magnitude or absolute value). scalar.
> π½ì2 ± 2í
> π/4ì(2√) ± 1í1
---
:char: Ä
:ascii: 'a+
:type: verb
#1 Argument
get the argument (or phase or angle) of the complex number α. scalar.
> 2Ä ≡ 0
> 2íÄ ≡ π½
> _2Ä ≡ π
> _2íÄ ≡ π½-
> 2í2Ä ≡ π/4
#2 Atan2
calculate atan2(α, β). equivalent to `íÄ`. scalar.
> 0Ä2 ≡ 0
> 2Ä0 ≡ π½
> 0Ä_2 ≡ π
> _2Ä0 ≡ π½-
---
:char: Å
:ascii: 'aO
:type: verb
#1 Radians
converts α radians to degrees. equivalent to `*├:180/π`. scalar.
> 2*πÅ ≡ :360
> πÅ ≡ :180
> π½Å ≡ :90
> π¼Å ≡ :360
#2 Absolute Difference
calculate the absolute difference of α and β. equivalent to `-¢`. scalar.
> 3Å5 ≡ 2
> 5Å3 ≡ 2
> Φ↕Å3 ≡ 3210123456
---
:char: É
:ascii: 'e+
:type: verb
#1 Is Scalar
returns 1 if α is a scalar, otherwise 0. equivalent to `ε¬`
> 4É ≡ 1
> 456É ≡ 0
> (▲)É ≡ 0
see also: ||Is List||
#2 Excludes
for every item in the list α, check if it is not in β. equivalent to `ε¬`
> 0123456789É012073167140 ≡ 0000010011
> 1 É 012073167140 ≡ 0
> 5 É 012073167140 ≡ 1
> "unauthorized equation"É"aeiou" ≡ 010011010101101001001
see also: ||Includes||
---
:char: æ
:ascii: 'ae
:type: verb
#2 Join
join the lists in α with the separator β
> "bee""bees""apioids"æ` ◄ ≡ "bee bees apioids"
> 123ªæ", " ≡ "1, 2, 3"
> "Hello"æ`f ≡ "Hfeflflfo"
---
:char: Æ
:ascii: 'aE
:type: verb
#1 Expand
turn α into an infinite list, where the items outside the list are α's fill. equivalent to `{┴@α}`
> 123~ ≡ 3
> 123Æ~ ≡ ∞
> 123╒+45 ≡ 57
> 123╒+(45▐0) ≡ 57
> 123╒+(45▐0Æ) ≡ 573
> 123╒+(45Æ) ≡ 57■
---
:char: ô
:ascii: 'o^
:type: verb
#1 Cosine
calculate `cos α`. scalar.
> 0ô ± 1
> π/6ô ± 3√½
> π/4ô ± 2√½
> π/3ô ± 1½
> π/2ô ± 0
> πô ± Θ
> π*3½ô ± 0
> π*2ô ± 1
#2 Bitwise Or
calculate bitwise OR of integers α and β. scalar.
> (0011è)ô(0101è) ≡ 0111è
---
:char: ö
:ascii: 'o"
:type: verb
#1 Arccosine
calculate `arccos α` or `cos⁻¹ α`. scalar.
> Θö ± π
> 0ö ± π½
> 1ö ± 0
#2 Nor
compute boolean NOR of α and β. scalar. equivalent to `&#x7c;¬`.
> 0ö0 ≡ 1
> 0ö1 ≡ 0
> 1ö0 ≡ 0
> 1ö1 ≡ 0
---
:char: ò
:ascii: 'o`
:type: verb
#1 Eval
evaluate the codepage string α in the current context, and return the value
> "1+1"ò ≡ 2
it will have access to all defined variables in the enclosing scopes, all the input and output streams and the random number generator. don't use this from untrusted sources blah blah blah blah.
> 4→value· "6↔value"ò· .value ≡ 6
---
:char: û
:ascii: 'u^
:type: verb
#1 Occurence Count
for every element of α, count the number of occurences of that element in the prefix before that element.
> 320110433250û ≡ 000011012102
therefore, `û¬` detects if an element is the first in the array:
> 320110433250û¬ ≡ 111100100010
> 320110433250(û¬)╓‼ ≡ 320145  ' same as α∩
#2 Unique Index Of
for every element in β, find the index of the first unused match in α, or ||None||.
> 22235 û 223357 ≡ 013■4■
> 3333 û 3323 ≡ 01■2
---
:char: ù
:ascii: 'u`
:type: verb
#1 Real Part
get the real part of a complex number α. scalar.
> 3í4ù ≡ 4
> 3ù ≡ 3
#2 Count
count the number of occurences of β in α. β-pervasive.
> 012073167140ù0123456789 ≡ 3311101200
---
:char: ÿ
:ascii: 'y"
:type: verb
#1 Deindices
a list of length `αÑ` with fill 0, where the value of an element `i` is the amount of occurences of `i` in α
> 134679ÿ ≡ 0101101101▐0
> 02244455557ÿ ≡ 10203401▐0
> 75420542545ÿ ≡ 10203401▐0
---
:char: Ö
:ascii: 'o+
:type: verb
#2 Write
write a string α, UTF-8 encoded, to output stream β. returns the number of bytes written, or ||None|| if there was some IO error.
#1 Write Stdout
write a string α to output stream 0. equivalent to `Ö0`.
see also: ||Print||
#_2 Write Bytes
write a list of bytes α to output stream β. returns the number of bytes written, or ||None|| if there was some IO error.
#_1 Write Bytes to Stdout
write a list of bytes α to output stream 0. equivalent to `_Ö0`.
---
:char: Ü
:ascii: 'u+
:type: verb
#2 Read
read α bytes from input stream β and decode them from UTF-8. invalid sequences are replaced with � U+FFFD REPLACEMENT CHARACTER.
for `α=∞`, read until the end of file. for `α=Θ`, read until the next line break (0x0A byte).
may return ||None|| in case of an IO error.
#1 Read Stdin
read from input stream 0. equivalent to `Ü0`.
#_2 Read Bytes
read α bytes from input stream β.
for `α=∞`, read until the end of file. for `α=Θ`, read until the next line break (0x0A byte).
may return ||None|| in case of an IO error.
#_1 Read Bytes from Stdin
read from input stream 0. equivalent to `_Ü0`.
---
:char: ¢
:ascii: 'C
:type: verb
#1 Absolute
get the absolute value of α. for complex numbers, this is the magnitude or modulus. scalar.
> 5¢ ≡ 5
> 0¢ ≡ 0
> _4¢ ≡ 4
> 3í4¢ ≡ 5
#2 Distance
calculate `α²+(β²)√`, or the distance of (α, β) to the origin (0, 0), or the absolute value of `αíβ`. scalar
> 3¢4 ≡ 5
> 8¢6 ≡ :10
> 1¢1 ≡ 2√
---
:char: £
:ascii: 'fd
:type: verb
#2 Find
finds all non-overlapping occurances of sublist β in α. returns a list of the same length as α, where the matches are represented as increasing indices of the sublist, and non-matches are ||None||. if β is a scalar or the ||Empty List||, search for the element β.
> "sus sus amongus"£`s    ≡ 0■0■0■0■■■■■■■0
> "sus sus amongus"£"s"   ≡ 0■0■0■0■■■■■■■0
> "sus sus amongus"£"us"  ≡ ■01■■01■■■■■■01
> "sus sus amongus"£"us " ≡ ■012■012■■■■■■■
> "sus sus amongus"£"sus" ≡ 012■012■■■■■■■■
> "bee beebeee beebe"£"ee"  ≡ ■01■■01■01■■■01■■
> "bee beebeee beebe"£"bee" ≡ 012■012012■■012■■
this is similar to using ||Scan Windows|| and ||Matches|| `α(►~)╫≡β` but this does not include overlapping matches
> "asininity"£"ini" ≡ ■■012■■■■
> "asininity"(►~)╫≡ "ini" ≡ 0010100  ' two matches!
its format is also a bit more convenient: same length as the original string, and you can do `=0` to find the starts of matches or ||Is Some|| `▀` to find all the matched characters:
> "sus sus amongus"£"sus"   ≡ 012■012■■■■■■■■
> "sus sus amongus"£"sus"=0 ≡ 100010000000000
> "sus sus amongus"£"sus"▀  ≡ 111011100000000
see also: ||Equals||, ||Scan Windows||, ||Split||
---
:char: ¥
:ascii: 'Y
:type: verb
#2 Split
splits a list α at all the ocurrences of the sublist β
> "bee bees apioids"¥` ◄ ≡ "bee""bees""apioids"
> "bee bees apioids"¥`,  ≡ ♪"bee bees apioids"
> "one, two, three"¥", " ≡ "one""two""three"
see also: ||Find||
#1 Split Newlines
splits at newlines (byte 0x0A). same as `¥Φ`. won't strip out carriage returns.
---
:char: ₧
:ascii: 'pt
:type: verb
#2 Partition
partition the list α at indexes β
> 0123456789₧46 ≡ (0123)(45)(6789)
> 0123456789₧0469Φ ≡ ()(0123)(45)(678)(♪9)()
#1 Parts
get a list of the real and imaginary parts of α. scalar. equivalent to `└ù♫ú`
> 4í_2 ₧ ≡ _2 4
> 4₧ ≡ 4 0
> 456_30í_2_3024₧ ≡ │_24│_35│06│2_3│40
---
:char: ƒ
:ascii: 'F 'f,
:type: verb_variable
#12 Self
the function being executed. if not in a function definition, undefined. useful for recursive functions.
> 6{=0?1◘α▼ƒ*α} ≡ :720
you shouldn't need this very often; in this case, `↨*` or `!` would have been enough. remember to include an exit condition using ||Return||. 
---
:char: á
:ascii: 'a'
:type: verb
#1 Pick
pick a random integer in the range [0, α). scalar.
> 5á ?≡ 3
> 5á ?≡ 2
> 5á ?≡ 4
> 5á ?≡ 0
if α is 0 or lower, pick a floating point value in the range [0, 1)
> 0á ?≡ :0.6902543350466662
#2 Picks
pick β times. this is the same as doing `α§βá`
> 5áΦ ?≡ 4 3 2 2 0 2 1 0 3 3
> 5á:100<5& ≡ 1
---
:char: í
:ascii: 'i'
:type: verb
#1 Imaginary
calculate `α*i`, where `i` is the imaginary unit. scalar.
> 1í ≡ Γ
> 3í ≡ 3*Γ
#2 Complex
calculate `β + α*i`. scalar.
> 1í² ± _1
> 2í² ± _4
> 3í2² ± :12í_5
---
:char: ó
:ascii: 'o'
:type: verb
#1 Signs
calculate (−1)^α. if α is an integer, this means −1 for odd α, and 1 for even α. scalar. equivalent to `┴^Θ`
> 012345ó ≡ 1Θ1Θ1Θ
see also: ||Minus One||
#2 Divides
return 1 if α is divisible by β, otherwise 0. scalar. equivalent to `%¬`
> 0ó3 ≡ 1
> 1ó3 ≡ 0
> 2ó3 ≡ 0
> 3ó3 ≡ 1
> :20↕ó4 ≡ 10001000100010001000
see also: ||Remainder||
---
:char: ú
:ascii: 'u'
:type: verb
#1 Imaginary Part
get the imaginary part of a complex number α. scalar.
> 3í4ú ≡ 3
> 3ú ≡ 0
#2 Index of Last
find the last exact match in the list and return its index, or else ||None||. β-pervasive.
> 012073167140ú0123456789 ≡ :11 925Φ■78■■
---
:char: ñ
:ascii: 'n- 'n~
:type: verb
#2 Minimum
return the lowest number between α and β. scalar.
> 0ñ2 ≡ 0
> _3ñ0 ≡ _3
> _2ñ2 ≡ _2
> 1ñ5 ≡ 1
#1 Infimum
return the lowest number in α. equivalent to `╧ñ∞`
> 2398389292ñ ≡ 2
for an empty list, this returns infinity.
> φñ ≡ ∞
---
:char: Ñ
:ascii: 'n+
:type: verb
#2 Maximum
return the largest number between α and β. scalar.
> 1Ñ2 ≡ 2
> _2Ñ3 ≡ 3
> _2Ñ0 ≡ 0
#1 Supremum
return the greatest number in α. equivalent to `╧Ñ_∞`
> 381562124Ñ ≡ 8
for an empty list, this returns negative infinity.
> φÑ ≡ ∞-
---
:char: ª
:ascii: 'a,
:type: verb
#1 Represent
convert the number α to a string. scalar.
> :123ª ≡ "123"
> :123.45ª ≡ "123.45"
> 4í3ª ≡ "3+4i"
see also: ||Parse||
#2 Represent Base
convert the number α to a string in base β. behaviour unspecified for bases not in [2, 36]. scalar.
> :35ª2 ≡ "100011"
> :42ªΦ ≡ "42"
> :3054ª:16 ≡ "bee"
> :14774ª:36 ≡ "bee"
> :42405ª:16 ≡ "a5a5"
> :-42405ª:16 ≡ "-a5a5"
> 0ª:16 ≡ "0"
see also: ||Parse Base||, ||Encode Base||
---
:char: º
:ascii: 'o,
:type: verb
#1 Parse
convert the string/character α to a number, or ||None||
> `4º ≡ 4
> "123"º ≡ :123
> "123.45"º ≡ :123.45
> "123+5i"º ≡ 5í:123
see also: ||Represent||
#2 Parse Base
convert the string α in base β to a number. behaviour unspecified for bases not in [2, 36].
> "bee"º:16 ≡ :3054
> "bee"º:36 ≡ :14774
> "A5A5"º:16 ≡ :42405
see also: ||Represent Base||, ||Decode Base||
---
:char: ¿
:ascii: '?
:type: verb
#1 Diagonal
get the diagonal of length `α▬2ñ` of a list α
> "bus""red""are"¿ ≡ "bee"
> .►↑55¿ ≡ :0:6:12:18:24
> (100)(020)(003)¿ ≡ 123
#2 Select
index α with every item in β. equivalent to `╘@`.
> "abc""def""ghi"¿(22)(10)(11)(00) ≡ "idea"
---
:char: ⌐
:ascii: '_ 'bl
:type: verb
#1 Bool
returns 1 if `α~0`, otherwise 0. scalar.
> 0⌐ ≡ 0
> 1⌐ ≡ 1
> 3⌐ ≡ 1
> 2-⌐ ≡ 1
#2 Prepend
returns the list α with the item β added to the front.
> 123⌐4 ≡ 4123
> 123⌐456 ≡ (456)123
see also: ||Procatenate||, ||Append||
---
:char: ¬
:ascii: '-
:type: verb
#1 Not
returns 1 if `α=0`, otherwise 0. scalar
> 0¬ ≡ 1
> 1¬ ≡ 0
> 3¬ ≡ 0
> 2-¬ ≡ 0
#2 Append
returns the list α with the item β added to the back.
> 123¬4 ≡ 1234
> 123¬456 ≡ 123(456)
see also: ||Concatenate||, ||Prepend||
---
:char: ½
:ascii: 'hf
:type: verb
#1 Halve
equivalent to `/2`. scalar.
> 1½ ≡ :0.5
> 5½ ≡ :2.5
> 1½½ ≡ :0.25
#2 Lowest Common Denominator
calculates the ||lowest common denominator@https://en.wikipedia.org/wiki/Lowest_common_denominator|| of two integers α and β, or lcd(α, β). scalar.
> :12½:18 ≡ :36
> :30½:45 ≡ :90
---
:char: ¼
:ascii: 'db
:type: verb
#1 Double
equivalent to `*2`. scalar.
> 1¼ ≡ 2
> Φ¼ ≡ :20
> 5¼ ≡ :10
> 6½¼ ≡ 6
#2 Greatest Common Divisor
calculates the ||greatest common divisor@https://en.wikipedia.org/wiki/Greatest_common_divisor|| of two integers α and β, or gcd(α, β). scalar.
> 8¼:12 ≡ 4
> :30¼:45 ≡ :15
---
:char: ¡
:ascii: '@ 'ie
:type: verb
#1 Last
get the last element of the list in α
> "aeiou"¡ ≡ `u
> 123¡ ≡ 3
#2 Translate
index the array α for every scalar in α. equivalent to `_╛┴@`.
> 13524¡" aeiouy" ≡ "aiueo"
---
:char: «
:ascii: 'rl
:type: verb
#2 Rotate Left
moves the last β elements of the list α to the front. β-pervasive.
> 12345«1 ≡ 23451
> 12345«3 ≡ 45123
> 12345«5 ≡ 12345
> 12345«6 ≡ 23451
if β is negative, this acts like ||Rotate Right||.
> 12345«_3 ≡ 34512
#1 Rotate Left Once
equivalent to `«1`
> 12345« ≡ 23451
---
:char: »
:ascii: 'rr
:type: verb
#2 Rotate Right
moves the first β elements of the list α to the back. β-pervasive.
> 12345»1 ≡ 51234
> 12345»3 ≡ 34512
> 12345»5 ≡ 12345
> 12345»6 ≡ 51234
if β is negative, this acts like ||Rotate Left||.
> 12345»_3 ≡ 45123
#1 Rotate Right Once
equivalent to `»1`
> 12345» ≡ 51234
---
:char: ░
:ascii: 'l2
:type: literal
#░☺☻ Short Literal
shorthand for an ||Integer Literal|| with 2 bytes (same as `█2`)
---
:char: ▒
:ascii: 'l3
:type: literal
#▒☺☻♥ Long Literal
shorthand for an ||Integer Literal|| with 3 bytes (same as `█3`)
---
:char: ▓
:ascii: 'c2
:type: literal
#▓ab Digraph Literal
a 2 character literal.
> ▓() ≡ `(`)
> ▓012 ≡ (`0`1)2
see also: ||Character Literal||
---
:char: █
:ascii: 'il
:type: literal
#█4☺☻♥♦ Integer Literals
a convenient literal syntax for large integers by specifying their bytes. integer literals are length-prefixed: after the `█` there will be a digit from 1 to 8 that specifies the number of bytes of the integer. `░` ||Short Literal||s and `▒` ||Long Literal||s are equivalent to `█2` and `█3` respectively.
an example: `█3☻♥♦` is the number `131844`. the number after the `█` is 3, so it will read three bytes. those bytes are `☻` `♥` `♦`, which means the output will be 0x020304, or `2*256^2 + 3*256 + 4`, or 131844.
> █3☻♥♦ ≡ :131844
> █3☻♥♦ ≡ 2*(:256^2) + (3*:256) + 4
`▒` can also be used here:
> ▒☻♥♦ ≡ :131844
let's represent the number 123456789. we can either use the ||Base Encode|| function: 
> :123456789é:256 ≡ :7:91:205:21▐0
alternatively, get the raw ||Bits|| of the number, partition it into ||Chunks|| of 8 bits, and ||Decode Binary|| them:
> :123456789é♥8╕è ≡ :0:0:0:0:7:91:205:21
we can represent the bytes as a codepage string (see ||Format||):
>     :7:91:205:21ⁿ5☻·
> "•[═§"
if we try it out,
> █4•[═§ ≡ :123456789
byte literals support negative numbers as well, using the two's complement when the first byte is over 127. `░²²` is not `253*256 + 253` or 64009, it's `65536 - 64009` or −515.
> ░²² ≡ :-515
integers in vemf are represented with signed two's-complement integers, so this is the same as making all the other bytes 0xFF
> ░²²é♥8╕è ≡ :255:255:255:255:255:255:253:253
`█` is mostly useful when using large numbers. if your number happens to be a vemf constant or has a trivial computation, use that instead.
see also: ||Short Literal||, ||Long Literal||, ||Character Literal||, ||Digraph Literal||
---
:char: ▄
:ascii: 'hd
:type: verb
#1 Is None
1 if α is none, otherwise 0. scalar.
> ■▄ ≡ 1
> 12■456■78▄ ≡ 001000100
see also: ||Is Some||
#2 Denullify
if β is not 0, return ||None||, otherwise α. scalar.
> 123456789▄010103102 ≡ 1■3■5■■8■
see also: ||Nullify||
---
:char: ▌
:ascii: 'hl
:type: verb
#1 Fill Holes
replace ||None||s in the list α with its fill.
> 12■456■78▐0▌ ≡ 120456078▐0
> 12■456■78▌ ≡ 12■456■78
#2 Replace Holes
replace ||None||s in the list α with β.
> 12■456■78▌0 ≡ 120456078
---
:char: ▐
:ascii: 'hr
:type: verb
#1 Get Fill
gets the fill of the list α.
> 123▐ ≡ ■
#2 Set Fill
returns the list α with the fill changed.
> 123▐1▐ ≡ 1
---
:char: ▀
:ascii: 'hu
:type: verb
#1 Is Some
check if α is not null. same as `¬▄`. scalar.
> ■▀ ≡ 0
> 1▀ ≡ 1
> 12■456■78▀ ≡ 110111011
see also: ||Is None||
#2 Nullify
if β is 0, return ||None||, otherwise α. scalar.
> 123456789▀010103102 ≡ ■2■4■67■9
see also: ||Denullify||
---
:char: α
:ascii: 'A
:type: variable
#0 Alpha
the left argument. if not in a function definition, the first argument passed in the command line, or `δ@0`
> "left"{αÇ} ≡ "LEFT"
> "left"{αÇ}"right" ≡ "LEFT"
---
:char: β
:ascii: 'B
:type: variable
#0 Beta
the right argument. if not in a function definition, the second argument passed in the command line, or `δ@1`. if the function was called monadically, this will be ||None||.
> "left"{βÇ} ≡ ■
> "left"{βÇ}"right" ≡ "RIGHT"
---
:char: Γ
:ascii: 'g+
:type: noun
#0 Imaginary Unit
the ||imaginary Unit@https://en.wikipedia.org/wiki/Imaginary_unit|| i
> Γ ≡ Θ√
> 3*Γ+2 ≡ 3í2
#_0 Negative Imaginary Unit
the complex number -i, or `Γ-`
#.0 Euler–Mascheroni Constant
the number `0.5772156649015329`
---
:char: π
:ascii: 'p- 'pi
:type: noun
#0 Pi
||pi@https://en.wikipedia.org/wiki/Pi||, archimedes constant, ratio of a semicircle to its radius, or at least the best approximation possible in 64-bit floating point.
> π ≡ :3.141592653589793
#_0 Tau
the number `6.283185307179586`, or `π*2`
#.0 Half Pi
the number `1.5707963267948966`, or `π/2`
---
:char: Σ
:ascii: 's+
:type: variable
#0 Arity
the number of arguments passed (1 or 2). if not in a function definition, the number of arguments passed in the command-line (`δ~`, may not be 1 or 2).
---
:char: σ
:ascii: 's-
:type: noun
#0 Outer Alpha
references `α` from the outer scope. useful for defining adverbs or higher-order functions.
---
:char: μ
:ascii: 'm-
:type: noun
#0 Outer Beta
references `β` from the outer scope. useful for defining adverbs or higher-order functions.
---
:char: δ
:ascii: 'd-
:type: noun
#0 Arguments
the list of arguments passed in the command line (not including the executable name, flags or the script filename)
---
:char: Φ
:ascii: 'X 'f+
:type: noun
#0 Ten
the integer 10
> Φ ≡ :10
#_0 Minus Ten
the integer −10
> _Φ ≡ :-10
#.0 Euler's Number
||euler's number@https://en.wikipedia.org/wiki/E_(mathematical_constant)|| e, or the number `2.718281828459045`
> 1^ ≡ .Φ
---
:char: Θ
:ascii: 'Q 't+
:type: noun
#0 Minus One
the number −1
> Θ ≡ :-1
---
:char: δ
:ascii: 'd-
:type: noun
#0 Arguments
the list of arguments passed in the command line (not including the executable name, flags or the script filename)
---
:char: ∞
:ascii: 'if
:type: noun
#0 Infinity
positive infinity
> 5<∞ ≡ 1
#_0 Negative Infinity
negative infinity
> 5>_∞ ≡ 1
#.0 Maximum Integer
the maximum integer representable by a signed 64-bit integer, or `:9223372036854775807`
> .∞▲ ≡ :9223372036854775807
> .∞  ≡ :9223372036854775807
> .∞▼ ≡ :9223372036854775806
---
:char: φ
:ascii: 'Z 'f-
:type: noun
#0 Empty List
literal for an empty list with ||None|| fill
> φ~ ≡ 0
#.0 Golden Ratio
the number `1.618033988749895`, or `5√▲½`
#_0
the number `-0.6180339887498949`, or `5√▼-½`
---
:char: ε
:ascii: 'in 'e-
:type: verb
#1 Is List
returns 0 if α is a scalar, otherwise 1
> 4ε ≡ 0
> 456ε ≡ 1
> (▲)ε ≡ 1
see also: ||Is Scalar||
#2 Includes
for every item in the list α, check if it is in β. equivalent to `╛(╘≡&#x7C;)`
> 0123456789ε012073167140 ≡ 1111101100
> 1 ε 012073167140 ≡ 1
> 5 ε 012073167140 ≡ 0
> "unauthorized equation"ε"aeiou" ≡ 101100101010010110110
> "unauthorized equation"(ε*:32-)╓+"aeiou" ≡ "UnAUthOrIzEd EqUAtIOn"
see also: ||Excludes||
---
:char: ∩
:ascii: 'is
:type: verb
#1 Unique
remove duplicates from α
> 320110433250∩ ≡ 320145
#2 Intersection
return the items in list α that are not in β
> "hello world i am a vemf test"∩`  ≡ "      "
> "hello world i am a vemf test"∩"aeiou " ≡ "eo o i a a e e"
> "hello world i am a vemf test"∩"aeiou" ≡ "eooiaaee"
---
:char: ≡
:ascii: '=
:type: verb
#1 Is Not Empty
returns 1 if the length of α is 0, otherwise 0
> 123≡ ≡ 0
> φ≡ ≡ 1
#2 Matches
returns 1 if the values α and β are equal. functions always return false.
> 123≡123 ≡ 1
> 123≡1234 ≡ 0
> (+)≡(+) ≡ 0
see also: ||Equals||
---
:char: ±
:ascii: '+
:type: verb
#1 Signum
returns the signum of α. this is −1 for negative numbers, 1 for positive numbers, and 0 for zero. for complex numbers, this is generalized as `α/abs(α)` or `¢╓/`
> 5± ≡ 1
> 0± ≡ 0
> _3± ≡ Θ
> 4í± ≡ Γ
> 2í2± ≡ π/4ì
#2 Approximately Equal
checks that the floating point numbers α and β are almost (more-or-less) equal. this is computed as a relative and absolute tolerance of 2 to the power of −32, or roughly `{α¢β/(1αβ ¢) ≤ (:32-%) &#x7C;}`
> 3±3 ≡ 1
> 3±:3.0000000001 ≡ 1
> 3±:3.001 ≡ 0
> 3±4 ≡ 0
see also: ||Matches||
---
:char: ≥
:ascii: '>
:type: verb
#1 Sort Down
sorts the list α in descending order
> 143042≥ ≡ 443210
see also: ||Grade Down||, ||Sort Up||
#2 Greater Than Or Equal
return 1 if α ≥ β, else 0. scalar. equivalent to `<¬`
> 5≥3 ≡ 1
> 3≥3 ≡ 1
> 3≥5 ≡ 0
see also: ||Less Than Or Equal||, ||Greater Than||
#_2 Lexicographic Greater Than Or Equal
return 1 if α ≥ β, else 0. if any of the two elements are lists, it will compare lexicographically. equivalent to `_<¬`
see also: ||Lexicographic Greater Than||, ||Lexicographic Less Than||
---
:char: ≤
:ascii: '<
:type: verb
#1 Sort Up
sorts the list α in ascending order
> 143042≤ ≡ 012344
see also: ||Grade Up||, ||Sort Down||
#2 Less Than Or Equal
return 1 if α ≤ β, else 0. scalar.
> 5≤3 ≡ 0
> 3≤3 ≡ 1
> 3≤5 ≡ 1
see also: ||Greater Than Or Equal||, ||Less Than||
#_2 Lexicographic Greater Than Or Equal
return 1 if α ≤ β, else 0. if any of the two elements are lists, it will compare lexicographically. equivalent to `_>¬`
see also: ||Lexicographic Less Than||, ||Lexicographic Greater Than||
---
:char: ⌠
:ascii: 'cl
:type: verb
#1 Ceiling
round up α. scalar.
> :3.1⌠ ≡ 4
> :3.9⌠ ≡ 4
>    4⌠ ≡ 4
see also: ||Floor||, ||Round||, ||Euclidean Division||
#2 Shift Right
returns a list of the same length as α, with every item shifted to the right by β, using the fill of α to fill the blanks. β-pervasive.
> 12345678⌠3 ≡ ■■■12345
> 87654321▐0⌠5 ≡ 00000876▐0
> "yeah!!!"▐` ⌠4 ≡ "    yea"▐` 
> "yeah!!!"▐` ⌠2 ≡ "  yeah!"▐` 
> (012)(345)(678)▐000⌠1 ≡ (000)(012)(345)▐000
a negative β acts like ||Shift Left||:
> "yeah!!!"▐` ⌠_2 ≡ "ah!!!  "▐` 
and if `α~≤β`, the whole list will be filled:
> 12345678⌠8 ≡ ■■■■■■■■
see also: ||Shift Left||, ||Rotate Right||
---
:char: ⌡
:ascii: 'fl
:type: verb
#1 Floor
round down α. scalar.
> :3.1⌡ ≡ 3
> :3.9⌡ ≡ 3
>    4⌡ ≡ 4
see also: ||Ceiling||, ||Round||
#2 Shift Left
returns a list of the same length as α, with every item shifted to the left by β, using the fill of α to fill the blanks. β-pervasive.
> 12345678⌡3 ≡ 45678■■■
> 87654321▐0⌡5 ≡ 32100000▐0
> "yeah!!!"▐` ⌡4 ≡ "!!!    "▐` 
> "yeah!!!"▐` ⌡2 ≡ "ah!!!  "▐` 
> (012)(345)(678)▐000⌡1 ≡ (345)(678)(000)▐000
a negative β acts like ||Shift Right||:
> "yeah!!!"▐` ⌡_2 ≡ "  yeah!"▐` 
and if `α~≤β`, the whole list will be filled:
> 12345678⌡8 ≡ ■■■■■■■■
see also: ||Shift Right||, ||Rotate Left||
---
:char: ÷
:ascii: '%
:type: verb
#1 Round
rounds α to the closest integer. may do round-half-to-even rounding. scalar.
> :3.1÷ ≡ 3
> :3.9÷ ≡ 4
>    4÷ ≡ 4
see also: ||Floor||, ||Ceiling||
#2 Euclidean Division
calculates the euclidean division of α and β, which will always be an integer. for positive β, this is the same as floor division `α/β⌡`. for any α and β, `β*(α÷β) + (α%β) ≡ α`.
> :345÷Φ ≡ :34
> :345÷:25 ≡ :13
> 1÷2 ≡ 0
> 1÷_2 ≡ 0
> _1÷2 ≡ _1
> _1÷_2 ≡ 1
see also: ||Remainder||, ||Floor||, ||Divide||
---
:char: ≈
:ascii: '~
:type: verb
#1 Is Empty
returns 1 if the length of α is not 0, otherwise 0
> 123≈ ≡ 1
> φ≈ ≡ 0
#2 Not Matches
equivalent to `≡¬`
> 123≈123 ≡ 0
> 123≈1234 ≡ 1
> (+)≈(+) ≡ 1
see also: ||Matches||
---
:char: °
:ascii: 'dg
:type: verb
#1 As Degrees
converts α degrees to radians. equivalent to `*├π/:180`. scalar.
> 0° ≡ 0
> :90° ≡ π½
> :180° ≡ π
> :270° ≡ 3*π½
> :360° ≡ 2*π
> :69°Å ± :69
---
:char: ¨
:ascii: 'nm
:type: literal
#n Name
the identifier `name` as a string.
> ¨bee ≡ "bee"
> ¨things¨words¨concepts ≡ "things""words""concepts"
---
:char: ·
:ascii: '&
:type: statement
#a· Discard
statement that discards the value `a` and continues with the function or program.
> 0{4·5·6} ≡ 6
see also: ||Return||
---
:char: √
:ascii: 'V
:type: verb
#1 Square Root
calculate the square root of α. scalar.
> 2√ ≡ :1.4142135623730951
> :1:4:9:16√ ≡ 1234
#2 Root
calculate the βth root of α. scalar.
> 2√3^3 ≡ 2
---
:char: ⁿ
:ascii: 'n, 'ft
:type: verb
#1 Default Format
format α with default settings. equivalent to `ⁿ1`
> :123ⁿ ≡ "123"
> 123ⁿ ≡ "(1 2 3)"
#2 Format
when this is called with a right argument, it will be interpreted in the following way:
- 0: format for printing (see ||Execution||)
- 1: default format
- 2: integer
- 3: Unicode character
- 4: Unicode string
- 5: codepage string
- 7: line-separated list
- 8: left-aligned list of lists
- 9: right-aligned list of lists
you can also use multiple of these in a list, like `ⁿ74` (line-separated list of strings)
`8` and `9` are useful for neatly formatted tables:
>     )9 :99↑44á
> ((13  4  6 26)
>  (53  7 18 72)
>  (54 45 84 87)
>  (36 41 13 60))
---
:char: ²
:ascii: 'z, 'sq
:type: verb
#1 Square
equivalent to `^2`. scalar.
> 4² ≡ :16
> 0² ≡ 0
#2 Binomial Coefficient
calculate the binomial coefficient `α choose β`. scalar.
> 4²012345 ≡ 146410
---
:char: ■
:ascii: 'N
:type: noun
#0 None
none, null, nil, NaN. used as a dummy value sometimes.
see also: ||Is None||, ||Is Some||, ||Fill Holes||, ||Replace Holes||, ||Filter Holes||, ||Nullify||
---
:char: ╕
:ascii: '"
:type: 1-adverb
#1a1 Each
call G with each item in α.
> 123╕▲ ≡ 234
> 123╕(,0) ≡ (10)(20)(30)
> (123)(456)(789)╕♠ ≡ (321)(654)(987)
if α has a non-null fill, G is called to the fill as well:
> 01001▐0¬ ≡ 10110▐1
#2a1 Each
Each (along with its variants) is the main way of doing iteration in vemf. scalar functions (like ||Add|| or ||Minimum||) all use ||Conform||, which is similar to ||Each||, so all of this will apply to those functions as well.
> 123╕+456 ≡ 123+456
if both α and β are lists, pair the items up and call G between them.
> 123+456 ≡ (1+4)(2+5)(3+6)
> "abc"╕,"xyz" ≡ "ax""by""cz"
> 123*456 ≡ :4:10:18
if all non-scalar arguments have non-null fill, G is called with the fills as well:
> 0123▐0+1 ≡ 1234▐1
> 2315103▐4*(1021100▐2) ≡ 2025100▐8
when two lists have different lengths, the shorter list will use its fill to fill up the missing elements:
> 123+45 ≡ 57■
> 123+(45▐0) ≡ 573
> 567+01234 ≡ 579■■
> 567▐0+01234 ≡ 57934
> 567▐1+01234 ≡ 57945
> 567▐1+01234 ≡ 57945
if any argument is a scalar, it will be copied in each iteration (or equivalently, it is extended to the other argument's shape):
> 123╕,0 ≡ │10│20│30
> 1234╕{αⁿ;`#} ≡ "#1""#2""#3""#4"
> 1234ª╕(;`#) ≡ "#1""#2""#3""#4"
> 1234ª╕;`# ≡ "#1""#2""#3""#4"
if both arguments are scalars, it just applies the operation on them
> 1╕,2 ≡ 12
if any of the arguments is a function, it treats it as an infinite list, composing the operation to it:
> .◄+1↑Φ ≡ 123456789Φ
> .◄*(ó2)↑Φ ≡ 0020406080
Each applies only to one level of nesting, unlike ||Conform||:
> (│01│23)(│45│67)(89),0 ≡     (│01│23)(│45│67)(89)0
> (│01│23)(│45│67)(89)╕,0 ≡    (│01│230)(│45│670)(890)
> (│01│23)(│45│67)(89)╕╕,0 ≡   (├010├230)(├450├670)(│80│90)
> (│01│23)(│45│67)(89)╕╕╕,0 ≡  (││00│10││20│30)(││40│50││60│70)(│80│90)
> (│01│23)(│45│67)(89)╕╕╕╕,0 ≡ (││00│10││20│30)(││40│50││60│70)(│80│90)
> (│01│23)(│45│67)(89)_╕,0   ≡ (││00│10││20│30)(││40│50││60│70)(│80│90)
see also: ||Each Left||, ||Each Right||, ||Conform||
#_1a1 Conform
call F to every scalar in α, keeping the list's structure. this is similar to ||Each|| called arbitrarily many times.
> (│01│23)(│45│67)(89)▲ ≡ (│12│34)(│56│78)(9Φ)
> (│01│23)(│45│67)(89) _╕(,0) ≡ (││00│10││20│30)(││40│50││60│70)(│80│90)
#_2a1 Conform
apply a function to every scalar in α and β, following the same rules as ||Each||, recursively.
> 0(123)(456)(789) _╕+ 0(123)(12)1 ≡ 0(246)(57■)(89Φ)
> (│01│23)(│45│67)(89) _╕, 0 ≡ (││00│10││20│30)(││40│50││60│70)(│80│90)
> 123_╕,456 ≡ (14)(25)(36)
> 123(45)6 _╕, 6789 ≡ (16)(27)(38)(│49│59)(6■)
---
:char: ╒
:ascii: 'et
:type: 1-adverb
#a1 Each Trim
similar to ||Each||, but instead of extending the shorter list to fit, it will clip the longer list to match the shorter one. the resulting list will always have ||None|| fill.
> 123╒+45 ≡ 57
> 12╒+345 ≡ 46
> 12▐6╒+(345▐7) ≡ 46
this also means it is useful with functions, taking as many items as needed:
> 3245╒*(┴^Φ) ≡ :3:20:400:5000
> 01101010╒*.◄ ≡ 01204060
---
:char: ╛
:ascii: '}
:type: 1-adverb
#2a1 Each Left
iterates through α, passing β in each iteration
> 123╛♫456 ≡ (1├456)(2├456)(3├456)
> 123╛;1 ≡ (11)(12)(13)
see also: ||Each Right||
#1a1 Each Left
monadically, this is the same as ||Each||:
> 123╛; ≡ (11)(22)(33)
#_2a1 Extend
call G to every scalar in α, keeping the list's structure, while passing β in each iteration.
> (123)(45)6 _╛, 78 ≡ (├178├278├378)(├478├578)├678
see also: ||Extend Right||
#_1a1 Extend
monadically, it is the same as ||Conform||:
> (123)(45)6 _╛♫ ≡ (♪1♪2♪3)(♪4♪5)♪6
---
:char: ╘
:ascii: '{
:type: 1-adverb
#2a1 Each Right
iterates through β, passing α in each iteration
> 123╘♫456 ≡ (├1234)(├1235)(├1236)
see also: ||Each Left||
#1a1 Each Right
monadically, it acts like `┴╘f`; iterates through α, passing it in each iteration
> 123╘* ≡ ((123)(246)(369))
> 123╘╛, ≡ (│11│21│31)(│12│22│32)(│13│23│33)
#_2a1 Extend Right
call G to every scalar in β, keeping the list's structure, while passing α in each iteration.
> 78 _╘, (123)(45)6 ≡ (├781├782├783)(├784├785)├786
see also: ||Extend||
#_1a1 Extend
monadically, this is equivalent to `α_╘Gα`:
> (123)4 _╘, ≡ ( (├12341) (├12342) (├12343) ) (├12344)
---
:char: ╤
:ascii: '\
:type: 1-adverb
#1a1 Scan
||Reduce||, but keeping the intermediate results. the first element will be left unchanged.
> 12345╤+ ≡ :1:3:6:10:15
> 12345╤, ≡ 1(12)(123)(1234)(12345)
#2a1 Seeded Scan
give an element to start with.
> 12345╤+1 ≡ :2:4:7:11:16
---
:char: ╧
:ascii: '/
:type: 1-adverb
#1a1 Reduce
apply a dyadic operation over the elements a list, left to right, progressively building up a value.
this can be thought of as inserting the function between every element:
> 12345╧♫ ≡ (((12)3)4)5
> 1♫2♫3♫4♫5 ≡ (((12)3)4)5
the ||Sum|| of a list is Reduce Add:
> 12345╧+   ≡ :15
> 1+2+3+4+5 ≡ :15
> 12345+    ≡ :15
> 1234╧* ≡ :24
you can fold starting from the right (as in `foldr` in haskell) with ||Reverse|| and ||Swap/Selfie||:
> 12345♠╧┴♫ ≡ 1(2(3(45)))
an empty list will yield null. a one element list (or a scalar) will return itself.
> φ╧+ ≡ ■
> ♪8╧+ ≡ 8
see also: ||Scan||
#2a1 Seeded Reduce
gives an element to start with. `α╧fβ` is always `α⌐β╧f`. this also means the empty list will return `β`; in fact, this is how ||Sum|| and ||Product|| are implemented.
> 12345╧+0 ≡ :15
> φ╧+0 ≡ 0
---
:char: ┬
:ascii: '|
:type: 1-adverb
#1a1 Filter
call G to all elements of α, and return the list including only the items that returned a non-zero value. equivalent to `(╛G⌐)╓‼` or `α╛G⌐‼α`
> 2370236075060501070613┬(<3) ≡ 20200001001
> "Sample text was first invented by James Sample in 1894."┬(≥"a{"+~1) ≡ "S      J S  1894."
see also: ||Replicate||, ||Power||
#1a2 Filter
bind β to G
> 2370236075060501070613┬<3 ≡ 20200001001
---
:char: ┴
:ascii: '`
:type: 1-adverb
#1a1 Selfie
equivalent to `αGα`
> 5+5 ≡ 5┴+
#2a1 Swap
equivalent to `βGα`
> 1/4 ≡ 4┴/1
---
:char: ┐
:ascii: 'tl
:type: 1-adverb
#a1 To Left
executes G with the left argument, ignoring the right argument. equivalent to `(◄G)`.
> 3▲   ≡ 4
> 3┐▲  ≡ 4
> 3┐▲7 ≡ 4
---
:char: ┌
:ascii: 'tr
:type: 1-adverb
#a1 To Right
executes G with the right argument, or the left argument if not given. equivalent to `(►G)`.
> 3▲   ≡ 4
> 3┌▲  ≡ 4
> 3┌▲4 ≡ 5
---
:char: ┼
:ascii: 'fp
:type: 1-adverb
#1a1 Fix Point
execute G repeatedly until the value stops changing. equivalent to `≡_╩`
> 1┼(/▲) ≡ 5√▲½  ' golden ratio
see also: ||Until Compare||
---
:char: ╪
:ascii: 's2
:type: 1-adverb
#1a1 Scan Pairs
run F through 2-item pairs of α, passing the left item as the left argument and the right item as the right argument. the first item will be left unchanged.
> 12345 ╪+ ≡ 13579
> 23456 ╪+1 ≡ 3579:11
#2a1 Scan Pairs
run F through 2-item pairs of α, passing the left item as the left argument and the right item as the right argument. β will be passed as the left item to the first item of the result.
> 12345 ╪♫ ≡ 1(12)(23)(34)(45)
> 12345 ╪♫0 ≡ (01)(12)(23)(34)(45)
---
:char: ╬
:ascii: 'vl
:type: 2-adverb
#1a2 Valences
call F.
> 1{"monad ",│αⁿ}╬{"dyad ",│αⁿ,` ,│βⁿ} ≡ "monad 1"
> 1■╬►  ≡ ■
#2a2 Valences
call G.
> 1{"monad ",│αⁿ}╬{"dyad ",│αⁿ,` ,│βⁿ}2 ≡ "dyad 1 2"
> 1■╬►2 ≡ 2
---
:char: ╦
:ascii: 'su
:type: 2-adverb
#1a2 Scan Until
call a function G repeatedly, returning all the different iterations, until F passes. F is passed the current iteration as α and the last iteration as β.
> :100(<5)╦½ ≡ :100:50:25:12.5:6.25:3.125
see also: ||Until||
#2a2 Scan Until
bind β to G
#_1a2 Scan Until Compare
call a function G repeatedly, returning all the different iterations, until `αGFα` passes: F is passed the current iteration as α and the last iteration as β.
> 1≡_╦(/▲) ↑:12 *_f⌡/_f ≡ :1.000:2.000:1.500:1.666:1.600:1.625:1.615:1.619:1.617:1.618:1.617:1.618
see also: ||Until Compare||
#_2a2 Scan Until Compare
bind β to G
---
:char: ╩
:ascii: 'U
:type: 2-adverb
#1a2 Until
call a function G repeatedly, returning the first result where `αF` passes.
> :100(<5)╩½ ≡ :3.125
> :100(<1)╩½ ≡ :0.78125
see also: ||Scan Until||
#2a2 Until
bind β to G
#_1a2 Until Compare
call a function G repeatedly, returning the first result where `αGFα` passes: F is passed the current iteration as α and the last iteration as β. `≡_╩` is the same as ||Fix Point||:
> 1≡_╩(/▲) ≡ 5√▲½  ' golden ratio
#_2a2 Until Compare
bind β to G
---
:char: ╥
:ascii: 'sp
:type: 2-adverb
#1a2 Scan Power
call a function G repeatedly, `αF` times. F will be executed with the arguments. this will return a list of length `αf+1`, including the original value.
> :100 7╥½ ≡ :100:50:25:12.5:6.25:3.125:1.5625:0.78125
#2a2 Scan Power
bind β to F and G
---
:char: ╨
:ascii: 'P
:type: 2-adverb
#1a2 Power
call a function G repeatedly, `αF` times. F will be executed with the arguments.
> :100 7╨½ ≡ :0.78125
if the result of `αF` is a list, repeat each of the elements.
> 123456789 (020110000)╨¼ ≡ 1838Φ6789
> 1(23)()(4()56)()(89) ≡╕╨Θ ≡ 1(23)Θ(4()56)Θ(89)
#2a2 Power
bind β to F and G
---
:char: ╫
:ascii: 'wn
:type: 2-adverb
#1a2 Scan Windows
apply a function G to each successive slice ("window") of length `αF` of the list α.
> "things" 3╫► ≡ "thi""hin""ing""ngs"
> 0123456 3╫+ ≡ 3:6:9:12:15
for a searched list of length `n` and window length `k`, the number of windows will be `n-k+1Ñ0` (even for `k=0`):
> "thing"0╫► ≡ ()()()()()()
see also: ||Scan Pairs||
#2a2 Power
bind β to G
---
:char: ╗
:ascii: 'dr
:type: 2-adverb
#1a2 Drill
return a list `α` with an item modified. the function G is run on item `αF`.
> (123)(456)(789) φ╗▲ ≡ (234)(567)(89Φ)
> (123)(456)(789) 0╗▲ ≡ (234)(456)(789)
> "x../xo./..o"(#`.)╗`x ≡ "xx./xo./..o"
if the result of `αF` is a list, it can modify items deep in a nested list:
> (123)(456)(789) (12)╗▲ ≡ (123)(457)(789)
#2a2 Drill
bind β to F
---
:char: ╔
:ascii: 'am
:type: 2-adverb
#1a2 Amend
return a list where the items at indices `αF` are modified by `G`.
> "hello world"(46789)╔Ç ≡ "hellO WORLd"
the whole list of the items to be modified is passed to G (`α¿(αF)G`) and its result is used to replace the items in α. this function is useful for modifying sublists (or substrings) in a list:
> "big brown fox"(4↕9)╔» ≡ "big nbrow fox"
> "big brown fox"(4↕9)╔(«2) ≡ "big ownbr fox"
> "big brown fox"(4↕9)╔"green" ≡ "big green fox"
> 0123456789(3↨7)╔▲ ≡ 0124567889
but there's no requirement that `αF` is contiguous, or in order:
> ". . . . . "(723904)╔"cheese" ≡ "s hee .c.e"
> 0123456789(681942)╔▼ ≡ 0013355778
if the result list from G is shorter than `αF`, the last indices will be removed from the list:
> "big brown fox"(4↕9)╔"blue" ≡ "big blue fox"
> 0248Φ(124)╔φ ≡ 08
and if the result list from G is longer than `αF`, the last values will be inserted after the last one:
> "big brown fox"(4↕9)╔(‼2) ≡ "big bbrroowwnn fox"
#2a2 Amend
bind β to F and G
---
:char: ╜
:ascii: ')
:type: 2-adverb
#1a2 At Left
equivalent to `αFG`.
#2a2 At Left
equivalent to `αFGβ`.
#_a2 Atop
adverb form of atop, same as the 2-train `FG`. `αF_╜G` is equivalent to `αFG`, and `αF_╜Gβ` is equivalent to `αFβG`. useful when composing functions tacitly.
see also: ||Trains||
---
:char: ╙
:ascii: '(
:type: 2-adverb
#1a2 At Right
equivalent to `aG`.
#2a2 At Right
equivalent to `αG(βF)`.
#_a2 Bind
adverb form of bind. same as the train `Gf`, where `f` is F interpreted as a noun, (or rather, `.F`). note that the arguments are reversed. `αf_╙G` and `αf_╙Gβ` are equivalent to `αGf`; this ignores the second operand. useful when composing functions tacitly.
see also: ||Trains||
---
:char: ╖
:ascii: ']
:type: 2-adverb
#1a2 On Left
equivalent to `αFGα`.
#2a2 On Left
equivalent to `αFβGβ`.
---
:char: ╓
:ascii: '[
:type: 2-adverb
#1a2 On Right
equivalent to `αG(αF)`.
#2a2 On Right
equivalent to `αG(αFβ)`.
---
:char: ║
:ascii: 'ov
:type: 2-adverb
#1a2 Over
equivalent to `αFG`.
#2a2 Over
equivalent to `αFG(βF)`.
---
:char: └
:ascii: 'K
:type: grammar
#α└FGH Fork
equivalent to `αFG(αH)`.
#α└FGHβ Fork
equivalent to `αFβG(αHβ)`.
---
:char: ─
:ascii: 'st
:type: grammar
#α─name Set Function
set a local variable `.name` to the value α. similar to `→name` ||Set|| but acts as a function.
> 2─two· .two+.two ≡ 4
after setting, it returns α. you can assign a function and use it right after:
> 2─two+.two ≡ 4
the uppercase ascii letters `A` `B` `C`... are assigned to be `─a` `─b` `─c` by default. this makes for a very convenient way of setting and querying variables:
> 2T+t ≡ 4  ' αT sets α to the variable `t` and returns α
this function is special in that, when used as a verb and called with two arguments, the right argument will be interpreted after the variable is set. this allows for code like this:
> 1A 2B (ab)+ ≡ 3
even if `(ab)` is an argument of `B`, and would logically other functions evaluate their arguments before calling them.
#α─nameβ Set Function
sets a variable to α in the local scope and returns β.
> 1─a2─b3─c a+b+c ≡ 6
> 1A2B3C +a+b ≡ 6
see also: ||Mutate Function||, ||Set||
---
:char: ═
:ascii: 'mt
:type: grammar
#a═name Mutate Function
change the variable `.name` using the function β. similar `↔name` ||Mutate|| but acts as a function. returns the changed value.
> 1→a .▲═a· a ≡ 2
> 1→a .▲═a+a ≡ 4
#α═nameβ Mutate Function
call the function with β as a right argument
> 1→a .+═a2· a ≡ 3
see also: ||Set Function||, ||Mutate||
---
:char: ┘
:ascii: '1
:type: grammar
#┘m Verbize
turns the following word into a verb. acts as a 1-grouper, see ||Groups||
#.0
the number `1.5`, or `3/2`
#_0
the number `-0.5`, or `Θ½`
---
:char: │
:ascii: '2
:type: grouper
#│mn 2-Group
see ||Groups||
#.0
the number `0.6666666666666666`, or `2/3`
#_0
the number `1.4142135623730951`, or `2√`
---
:char: ├
:ascii: '3
:type: grouper
#├mno 3-Group
see ||Groups||
#.0
the number `0.3333333333333333`, or `1/3`
#_0
the number `1.7320508075688772`, or `3√`
---
:char: ╞
:ascii: '4
:type: grouper
#╞mnop 4-Group
see ||Groups||
#.0
the number `0.25`, or `1/4`
#_0
the number `420`
---
:char: ╟
:ascii: '5
:type: grouper
#╟mnopq 5-Group
see ||Groups||
#.0
the number `0.75`, or `3/4`
#_0
the number `2.23606797749979`, `5√`
---
:char: ╠
:ascii: '6
:type: grouper
#╠mnopqr 6-Group
see ||Groups||
#.0
the number `0.16666666666666666`, or `1/6`
#_0
the number `360`
---
:char: ┤
:ascii: '7
:type: grouper
#┤mnopqrs 7-Group
see ||Groups||
#.0
the number `0.14285714285714285`, or `1/7`
#_0
the number `273.15`
---
:char: ╡
:ascii: '8
:type: grouper
#╡mnopqrst 8-Group
see ||Groups||
#.0
the number `0.125`, or `1/8`
---
:char: ╢
:ascii: '9
:type: grouper
#╢mnopqrstu 9-Group
see ||Groups||
#.0
the number `0.1111111111111111`, or `1/9`
---
:char: ╣
:ascii: '0
:type: grouper
#╣mnopqrstuv 10-Group
see ||Groups||
#.0
the number `2.5`, or `5/2`